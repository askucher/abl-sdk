// Generated by LiveScript 1.4.0
angular.module('ablsdk', []);
// Generated by LiveScript 1.4.0
angular.module('ablsdk').service('ablbook', function($xabl, p, stripe, debug, prefill, safeApply){
  return function(activity, globalCallback){
    var state, getDay, investigateDate, valid, issue, error, closeError, resetIdempotencyKey, few, sum, disabledOrder, cardify, getEventInstanceId, bookingProcess, stripeProcess, paymentSetup, validate, bookingSuccess, checkout, agree, isError, showErrorLogical, showError, fields, tryCheckout, message, placeholder, x$;
    state = {
      triedCheckout: false,
      typing: '',
      braintreeClient: null,
      loading: false,
      idempotencyKey: null,
      form: {
        error: "",
        agreed: false,
        email: '',
        name: '',
        phone: '',
        address: '',
        location: {},
        notes: '',
        date: {
          start: null,
          end: null
        },
        creditCard: {
          card: '',
          expDate: '',
          cvv: '',
          address_zip: ''
        }
      },
      calendar: {
        value: null,
        visible: false,
        currentActivity: activity,
        closed: function(chosen){
          debug('closed-calendar', chosen);
          state.form.date.start = state.calendar.date.start;
          state.form.date.end = state.calendar.date.end;
          return globalCallback('slot-chosen', chosen);
        }
      }
    };
    getDay = function(date){
      var res;
      if (date != null) {
        res = (date != null ? date.format : void 8) != null
          ? date
          : moment(date);
        return parseInt(
        res.format('YYYYMMDD'));
      } else {
        return null;
      }
    };
    investigateDate = function(bag){
      var _;
      return _ = (function(){
        switch (false) {
        case bag.start !== null:
          return 'none';
        case getDay(bag.start) === getDay(bag.end):
          return 'different';
        default:
          return 'same';
        }
      }());
    };
    valid = function(form){
      return !state.loading && form.$valid;
    };
    issue = function(form){
      var field, text;
      for (field in fields) {
        if (fields.hasOwnProperty(field)) {
          text = message(form, field);
          if ((text != null ? text.length : void 8) > 0) {
            return text;
          }
        }
      }
      return "Please check the form";
    };
    error = function(message){
      return state.form.error = message;
    };
    closeError = function(){
      return error("");
    };
    resetIdempotencyKey = function(){
      var s;
      return state.idempotencyKey = (s = function(){
        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
      }, s() + s() + '-' + s() + '-' + s() + '-' + s() + '-' + s() + s() + s());
    };
    resetIdempotencyKey();
    few = function(arr){
      var ref$;
      return (ref$ = arr != null ? typeof arr.filter == 'function' ? arr.filter(function(it){
        return it.quantity > 0;
      }) : void 8 : void 8) != null
        ? ref$
        : [];
    };
    sum = function(arr){
      switch (false) {
      case typeof arr !== 'undefined':
        return 0;
      case typeof arr !== null:
        return 0;
      case arr.length !== 0:
        return 0;
      default:
        return arr.reduce(function(x, y){
          return x + y;
        });
      }
    };
    disabledOrder = function(){
      return sum(state.calendar.calc.attendees.map(function(it){
        return it.quantity;
      })) === 0;
    };
    cardify = function(val, val2){
      var newval;
      newval = (function(){
        switch (false) {
        case val.length !== 4:
          return val + " ";
        case val.length !== 9:
          return val + " ";
        case val.length !== 14:
          return val + " ";
        case val.length !== 19:
          return val + " ";
        default:
          return val;
        }
      }());
      return newval + val2;
    };
    getEventInstanceId = function(){
      var eventId;
      if (state.calendar._id == null) {
        throw "Cannot get event instance id because calendar._id is not defined";
      }
      eventId = function(it){
        return it != null ? it.eventId : void 8;
      }(
      p.find(function(it){
        return it._id === state.calendar._id;
      })(
      activity.timeslots));
      if (eventId == null) {
        throw "event id is not found by id " + state.calendar._id + " in [" + activity.timeslots.map(function(it){
          return it._id;
        }).join(',') + "]";
      }
      return eventId + '_' + state.calendar.date.origin;
    };
    bookingProcess = function(token, callback){
      var f, a, makeNulls, coupon, free, req, ref$;
      f = state.form;
      a = activity;
      makeNulls = function(total){
        return p.map(function(){
          return null;
        })(
        (function(){
          var i$, to$, results$ = [];
          for (i$ = 1, to$ = total; i$ <= to$; ++i$) {
            results$.push(i$);
          }
          return results$;
        }()));
      };
      coupon = state.calendar.calc.coupon.codes.length > 0;
      free = state.calendar.calc.calcTotal() === 0;
      req = {
        isMobile: (ref$ = f.isMobile) != null ? ref$ : false,
        stripeToken: token,
        couponId: coupon ? state.calendar.calc.coupon.codes[0].couponId : undefined,
        paymentMethod: (function(){
          switch (false) {
          case !(free && coupon):
            return 'gift';
          case !free:
            return 'cash';
          default:
            return 'credit';
          }
        }()),
        eventInstanceId: getEventInstanceId(),
        addons: p.pairsToObj(
        p.map(function(a){
          return [a._id, makeNulls(a.quantity)];
        })(
        state.calendar.calc.addons)),
        attendees: p.pairsToObj(
        p.map(function(a){
          return [a._id, makeNulls(a.quantity)];
        })(
        state.calendar.calc.attendees)),
        answers: p.pairsToObj(
        p.map(function(a){
          return [a._id, a.answer];
        })(
        state.calendar.questions)),
        adjustments: state.calendar.calc.adjustment.list,
        fullName: f.name,
        email: f.email,
        phoneNumber: f.phone,
        notes: f.notes,
        location: f.location,
        currency: 'usd',
        _customHeaders: {
          "Idempotency-Key": state.idempotencyKey
        }
      };
      return $xabl.post('bookings', req).success(function(data){
        var ref$, ref1$;
        if (data.bookingId != null) {
          f.bookingId = data.bookingId;
          resetIdempotencyKey();
          return callback(data);
        } else {
          return error((ref$ = (ref1$ = e.errors) != null ? ref1$[0] : void 8) != null ? ref$ : "Server error");
        }
      }).error(function(e){
        var ref$, ref1$;
        return error((ref$ = (ref1$ = e.errors) != null ? ref1$[0] : void 8) != null ? ref$ : "Server error");
      })['finally'](function(){
        return state.loading = false;
      });
    };
    stripeProcess = function(key, callback){
      var cc, expDate, f, req, ref$;
      if (typeof key === 'undefined') {
        state.loading = false;
        return error("Stripe key is not defined");
      }
      stripe.setPublishableKey(key);
      cc = state.form.creditCard;
      expDate = cc.expDate.split('/');
      f = state.form;
      req = {
        number: cc.card,
        cvc: cc.cvv,
        address_zip: cc.address_zip,
        exp_month: expDate[0],
        exp_year: "20" + expDate[1],
        fullName: (ref$ = f.fullName) != null
          ? ref$
          : f.name,
        location: f.location,
        state: f.state
      };
      return stripe.createToken(req, function(err, token){
        if (err != null) {
          state.loading = false;
          return error(err);
        }
        return bookingProcess(token, callback);
      });
    };
    paymentSetup = function(){
      return $xabl.get('payments/setup');
    };
    validate = function(form){
      var isValid;
      if (state.loading === true) {
        return false;
      }
      state.triedCheckout = true;
      isValid = valid(form);
      if (!isValid) {
        error(issue(form));
      }
      return isValid;
    };
    bookingSuccess = function(booking){
      state.booking = booking;
      return globalCallback('success', booking);
    };
    checkout = function(form, moreData){
      if (validate(form)) {
        state.loading = true;
        if (state.calendar.calc.calcTotal() > 0) {
          return paymentSetup().success(function(data){
            return stripeProcess(data.publicKey, bookingSuccess);
          }).error(function(err){
            state.loading = false;
            error(err);
            return globalCallback('error', error);
          });
        } else {
          return bookingProcess("", bookingSuccess);
        }
      }
    };
    agree = function(){
      state.form.agreed = !state.form.agreed;
      return tryCheckout();
    };
    isError = function(v){
      return v.required || v.pattern || v.minlength || v.maxlength || v.phone;
    };
    showErrorLogical = function(name, v){
      var s, show;
      s = fields[name].state;
      show = (function(){
        switch (false) {
        case !state.triedCheckout:
          return true;
        case !(!s.touched && !state.triedCheckout):
          return false;
        case !(s.active && !state.triedCheckout):
          return false;
        case !(!s.active && s.touched):
          return true;
        default:
          return false;
        }
      }());
      if (show) {
        return showError(name, v);
      } else {
        return "";
      }
    };
    showError = function(name, v){
      switch (false) {
      case !v.required:
        return fields[name].title + " is required";
      case !v.pattern:
        return "Please follow the example " + fields[name].example;
      case !v.minlength:
        return fields[name].title + " is too short";
      case !v.maxlength:
        return fields[name].title + " is too long";
      case !v.phone:
        return fields[name].title + " is not valid phone number";
      default:
        return "please check " + fields[name].title;
      }
    };
    fields = {
      email: {
        title: "Email",
        pattern: /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$/i,
        example: 'nickname@email.com',
        placeholder: 'Email',
        state: {
          index: 1,
          touched: false,
          active: false
        }
      },
      name: {
        pattern: '',
        title: "Name",
        example: 'Your name',
        placeholder: 'Name',
        state: {
          index: 2,
          touched: false,
          active: false
        }
      },
      phone: {
        title: "Phone",
        pattern: /^[0-9]{3}[-][0-9]{3}[-][0-9]{3,5}$/i,
        placeholder: "Phone +1 123-456-1234",
        example: "+1 123-456-1234",
        state: {
          index: 3,
          touched: false,
          active: false
        }
      },
      address: {
        pattern: '',
        title: "Address",
        example: 'Address',
        placeholder: 'Home address',
        state: {
          index: 4,
          touched: false,
          active: false
        }
      },
      notes: {
        pattern: '',
        title: "Notes",
        example: "Notes",
        placeholder: "Notes",
        state: {
          index: 5,
          touched: false,
          active: false
        }
      },
      address_zip: {
        pattern: '',
        example: '12345',
        title: "Postal Code",
        placeholder: "Postal Code",
        normalize: function(value){
          return value;
        },
        state: {
          index: 6,
          touched: false,
          active: false
        }
      },
      card: {
        pattern: /[0-9]{4} [0-9]{4} [0-9]{4} [0-9]{4}/i,
        example: '0000 0000 0000 0000',
        title: "Credit Card",
        placeholder: "Credit Card Number",
        normalize: function(value){
          if (typeof value === 'undefined') {
            return;
          }
          return state.form.creditCard.card = function(it){
            return it.substr(0, 19);
          }(
          p.fold(cardify, "")(
          function(it){
            return it.split(' ').join('');
          }(
          value)));
        },
        state: {
          index: 7,
          touched: false,
          active: false
        }
      },
      expDate: {
        pattern: /[0-9]{2}\/[0-9]{2}/i,
        example: "05/15",
        title: "Exp Date",
        placeholder: 'Exp Date (MM/YY)',
        normalize: function(value){
          var e, ref$, t;
          e = (ref$ = value != null ? value.replace('/', '') : void 8) != null ? ref$ : "";
          t = function(it){
            return it != null ? it : "";
          };
          return state.form.creditCard.expDate = (function(){
            switch (false) {
            case e.length !== 2:
              return e[0] + e[1] + '/';
            case !(e.length > 2):
              return e[0] + e[1] + '/' + t(e[2]) + t(e[3]);
            default:
              return e;
            }
          }());
        },
        state: {
          index: 8,
          touched: false,
          active: false
        }
      },
      startDate: {
        state: {
          index: 11,
          touched: false,
          active: false
        }
      },
      cvv: {
        pattern: /[0-9]{3,4}/i,
        example: "000",
        title: "CVV",
        placeholder: "CVV",
        state: {
          index: 9,
          touched: false,
          active: false
        }
      },
      agreed: {
        title: "Confirmation",
        pattern: 'true',
        message: {
          required: "Please accept the terms and conditions"
        },
        state: {
          index: 10,
          touched: false,
          active: false
        }
      }
    };
    tryCheckout = function(){
      if (state.form.agreed) {
        return state.triedCheckout = true;
      }
    };
    message = function(form, name){
      var sorted, field, val, ref$;
      sorted = p.pairsToObj(
      p.sortBy(function(it){
        return it[1].state.index;
      })(
      p.objToPairs(
      fields)));
      for (field in sorted) {
        if (fields.hasOwnProperty(field)) {
          val = (ref$ = form[field]) != null ? ref$.$error : void 8;
          if (val && isError(val)) {
            if (field === name) {
              return showErrorLogical(field, val);
            }
            return "";
          }
        }
      }
      return "";
    };
    placeholder = function(name){
      return fields[name].placeholder;
    };
    prefill(function(){
      var f, c;
      f = state.form;
      f.email = "a.stegno@gmail.com";
      f.name = "Test User";
      f.phone = "+380665243646";
      f.address = "664 Cypress Lane, Campbell, CA, United States";
      f.notes = "Some test notes";
      c = state.form.creditCard;
      c.card = "5105 1051 0510 5100";
      c.address_zip = "12345";
      c.expDate = "05/17";
      c.cvv = "333";
      return state.form.agreed = true;
    });
    x$ = state;
    x$.handle = function(event){
      return safeApply(function(){
        var name, type, value, field;
        name = event.target.name;
        type = event.type;
        value = event.target.value;
        field = fields[name];
        if (field == null) {
          return;
        }
        switch (type) {
        case 'keyup':
          return typeof field.normalize == 'function' ? field.normalize(value) : void 8;
        case 'focus':
          field.state.active = true;
          return field.state.touched = true;
        case 'blur':
          return field.state.active = false;
        }
      });
    };
    x$.setIndex = function(name, index){
      var field;
      field = fields[name];
      if (field == null) {
        return index;
      }
      field.state.index = index;
      return index;
    };
    x$.investigateDate = investigateDate;
    x$.getEventInstanceId = getEventInstanceId;
    x$.placeholder = placeholder;
    x$.closeError = closeError;
    x$.checkout = checkout;
    x$.validate = validate;
    x$.agree = agree;
    x$.fields = fields;
    x$.few = few;
    x$.disabledOrder = disabledOrder;
    x$.message = message;
    return state;
  };
});
// Generated by LiveScript 1.4.0
angular.module('ablsdk').service('ablcalc', function($xabl, $timeout, p, debug, test){
  var sum;
  sum = function(arr){
    switch (false) {
    case typeof arr !== 'undefined':
      return 0;
    case typeof arr !== null:
      return 0;
    default:
      return p.sum(
      arr);
    }
  };
  return function(inputNewCharges, inputPrevousCharges, paid){
    var prevousCharges, newCharges, ref$, makeNewCharge, byPrice, makeOldCharge, oldAmounts, exclude, availableAmounts, getAmounts, state, totalAdjustment, calcSubtotal, calcTaxFee, calcTaxesFees, showPrice, calcPrice, showAddonPrice, calcAddonPrice, totalAddons, calcCoupon, warning, calcTotalWithoutCoupon, calcTotal, calcPreviousTotal, deposit, calcBalanceDue, adjustment, observers, onEvent, notify, coupon;
    prevousCharges = inputPrevousCharges != null
      ? inputPrevousCharges
      : [];
    newCharges = (ref$ = inputNewCharges != null ? inputNewCharges.filter(function(it){
      return it.status === 'active';
    }) : void 8) != null
      ? ref$
      : [];
    makeNewCharge = function(charge){
      return {
        name: charge.name,
        isDefault: charge.isDefault,
        quantity: 0,
        amount: charge.amount,
        _id: charge._id
      };
    };
    byPrice = function(a, b){
      return b.amount - a.amount;
    };
    makeOldCharge = function(arr){
      return {
        name: arr[0].name,
        isDefault: arr[0].isDefault,
        amount: arr[0].amount,
        quantity: arr.length,
        _ids: p.map(function(it){
          return it._id;
        })(
        arr)
      };
    };
    oldAmounts = function(type){
      return p.sortWith(byPrice)(
      p.map(makeOldCharge)(
      p.map(function(it){
        return it[1];
      })(
      p.objToPairs(
      p.groupBy(function(it){
        return it.name + it.amount;
      })(
      p.filter(function(it){
        return it.type === type;
      })(
      prevousCharges))))));
    };
    exclude = curry$(function(type, charge){
      var old;
      old = p.find(function(it){
        return charge.name === it.name && charge.amount === it.amount;
      })(
      oldAmounts(type));
      if (old != null) {
        old.old = true;
      }
      return old == null;
    });
    availableAmounts = function(type){
      return p.sortWith(byPrice)(
      p.filter(exclude(type))(
      p.map(makeNewCharge)(
      p.filter(function(it){
        return it.type === type;
      })(
      newCharges))));
    };
    getAmounts = function(type){
      var arr, isDefault, arr2;
      arr = p.sortBy(function(it){
        return it.amount;
      })(
      p.concat(
      p.map(function(it){
        return it(type);
      })(
      [oldAmounts, availableAmounts])));
      isDefault = p.filter(function(it){
        return it.isDefault;
      })(
      arr);
      arr2 = p.sortBy(function(it){
        return it.amount;
      })(
      p.filter(function(it){
        return isDefault.indexOf(it) === -1;
      })(
      arr));
      if (isDefault.length === 0) {
        return p.reverse(
        p.sortBy(function(it){
          return it.amount;
        })(
        arr));
      } else {
        return isDefault.concat(arr2);
      }
    };
    test(function(){
      return getAmounts('aap').length > 0;
    });
    test(function(){
      var top;
      top = p.head(
      getAmounts('app'));
      if (!top) {
        return true;
      }
      if (top.amount == null || top.quantity == null || top.name == null) {
        return false;
      }
    });
    state = {
      attendees: getAmounts('aap'),
      addons: getAmounts('addon')
    };
    totalAdjustment = function(){
      return p.sum(
      p.map(function(it){
        return it.amount;
      })(
      adjustment.list));
    };
    calcSubtotal = function(){
      return sum(
      state.attendees.map(calcPrice)) + totalAdjustment() + totalAddons();
    };
    calcTaxFee = function(charge){
      switch (false) {
      case charge.type !== 'tax':
        return calcSubtotal() / 100 * charge.amount;
      case charge.type !== 'fee':
        return sum(
        state.attendees.map(function(it){
          return it.quantity;
        })) * charge.amount;
      default:
        return 0;
      }
    };
    calcTaxesFees = function(){
      return sum(
      newCharges.map(calcTaxFee));
    };
    showPrice = function(attendee){
      var ref$, ref1$, ref2$;
      return (ref$ = (ref1$ = newCharges.filter(function(it){
        return it.type === 'aap' && it.name === attendee.name;
      })) != null ? (ref2$ = ref1$[0]) != null ? ref2$.amount : void 8 : void 8) != null ? ref$ : 0;
    };
    calcPrice = function(attendee){
      return showPrice(attendee) * attendee.quantity;
    };
    showAddonPrice = function(addon){
      return sum(
      state.addons.filter(function(it){
        return it.name === addon.name;
      }).map(function(it){
        return it.amount;
      }));
    };
    calcAddonPrice = function(addon){
      return showAddonPrice(addon) * addon.quantity;
    };
    totalAddons = function(){
      return sum(
      state.addons.map(calcAddonPrice));
    };
    calcCoupon = function(){
      var code, origin, ref$, percentage, currentPrice, result;
      code = coupon.codes[0];
      origin = Math.abs((ref$ = code != null ? code.amount : void 8) != null ? ref$ : 0);
      percentage = (ref$ = code != null ? code.percentage : void 8) != null ? ref$ : false;
      currentPrice = ((ref$ = code != null ? code.isTotal : void 8) != null ? ref$ : true)
        ? calcTotalWithoutCoupon()
        : calcSubtotal();
      result = (function(){
        switch (false) {
        case !(percentage === false && origin < currentPrice):
          return origin;
        case percentage !== false:
          return currentPrice;
        default:
          return currentPrice / 100 * origin;
        }
      }());
      return result * -1;
    };
    warning = function(charge, name){
      var removed, type, changed, res;
      removed = charge.status === 'inactive';
      type = charge.type;
      changed = charge.old;
      name = (function(){
        switch (false) {
        case type !== 'aap':
          return "pricing level";
        case type !== 'addon':
          return "add-on";
        }
      }());
      res = (function(){
        switch (false) {
        case !(removed && name === 'removed'):
          return "Warning: This " + name + " no longer exists. You can only reduce the quantity at this " + name + ". If you wish to offer another " + name + " at this price, please create on Adjustment to currect the price.";
        case !(changed && name === 'changed'):
          return "Warning: This " + name + " has changed since the booking was created. You can only reduce the quantity at this " + name + ". If you wish to offer the old " + name + ", please create an Adjustment.";
        case !((removed || changed) && name === 'mutated'):
          return true;
        default:
          return "";
        }
      }());
      return res;
    };
    calcTotalWithoutCoupon = function(){
      return calcSubtotal() + calcTaxesFees();
    };
    calcTotal = function(){
      return calcTotalWithoutCoupon() + calcCoupon();
    };
    calcPreviousTotal = function(){
      return p.sum(
      p.map(function(it){
        return it.amount;
      })(
      prevousCharges));
    };
    deposit = p.sum(
    p.map(function(it){
      return it.amount;
    })(
    paid != null
      ? paid
      : []));
    calcBalanceDue = function(){
      return -(calcTotal() - deposit);
    };
    adjustment = {
      list: p.filter(function(it){
        return it.type === 'adjustment';
      })(
      prevousCharges),
      name: "",
      amount: "",
      isEdit: false,
      show: false,
      add: function(){
        var newItem;
        newItem = {
          name: adjustment.name,
          amount: adjustment.amount
        };
        newItem.amount *= 100;
        adjustment.list.push(newItem);
        adjustment.name = "";
        adjustment.amount = "";
        adjustment.show = false;
        return adjustment.isEdit = false;
      },
      removable: function(item){
        return item._id == null;
      },
      remove: function(item){
        var index;
        index = adjustment.list.indexOf(item);
        return adjustment.list.splice(index, 1);
      },
      edit: function(c){
        if (adjustment.isEdit) {
          adjustment.add();
        }
        adjustment.name = c.name;
        adjustment.amount = c.amount / 100;
        adjustment.show = true;
        adjustment.isEdit = true;
        return adjustment.remove(c);
      }
    };
    observers = {};
    onEvent = function(event, func){
      var ref$;
      observers[event] = (ref$ = observers[event]) != null
        ? ref$
        : [];
      return observers[event].push(func);
    };
    notify = function(event, data){
      var list, ref$;
      list = (ref$ = observers[event]) != null
        ? ref$
        : [];
      return p.each(function(it){
        return it(data);
      })(
      list);
    };
    coupon = {
      codes: p.filter(function(it){
        return it.type === 'coupon';
      })(
      prevousCharges),
      calc: calcCoupon,
      show: false,
      edit: function(c){
        coupon.code = c.code;
        coupon.remove(c);
        return coupon.show = true;
      },
      remove: function(c){
        var index;
        index = coupon.codes.indexOf(c);
        if (index > -1) {
          return coupon.codes.splice(index, 1);
        }
      },
      add: function(activity){
        var ref$, apply;
        if (((ref$ = coupon.code) != null ? ref$ : "").length === 0) {
          return;
        }
        coupon.code = coupon.code.toUpperCase();
        coupon.error = (function(){
          switch (false) {
          case coupon.code.length !== 0:
            return "Code is required";
          case !(coupon.code.length < 6):
            return "6 chars are required";
          default:
            return "";
          }
        }());
        if (coupon.error.length > 0) {
          return;
        }
        apply = function(data){
          var success, startTime, redeemBy;
          success = function(){
            coupon.codes.push(data);
            notify('coupon-added', data);
            coupon.code = "";
            coupon.success = "Coupon " + data.couponId + " added successfully";
            coupon.show = false;
            $timeout(function(){
              var ref$;
              return ref$ = coupon.success, delete coupon.success, ref$;
            }, 3000);
            return "";
          };
          startTime = moment(data.startTime);
          redeemBy = moment(data.endTime);
          debug({
            startTime: startTime.format(),
            redeemBy: redeemBy.format(),
            check: startTime.diff(moment(), 'minutes'),
            check1: startTime.diff(redeemBy, 'minutes'),
            status: data.status,
            redemptions: data.maxRedemptions !== 0 && data.maxRedemptions <= data.redemptions,
            expired: moment().diff(redeemBy, 'minutes'),
            activity: data.activities.length > 0 && data.activities[0] !== activity
          });
          return coupon.error = (function(){
            switch (false) {
            case !(startTime.diff(moment(), 'minutes') > 0):
              return "Coupon is not valid yet";
            case data.status !== 'inactive':
              return "Coupon is inactive";
            case !(data.maxRedemptions !== 0 && data.maxRedemptions <= data.redemptions):
              return "This coupon has been fully redeemed.";
            case !(moment().diff(redeemBy, 'minutes') > 0):
              return "This coupon is expired";
            case !(data.activities.length > 0 && data.activities[0] !== activity):
              return "This coupon is not valid for this activity.";
            default:
              return success();
            }
          }());
        };
        return $xabl.get("coupon/" + coupon.code).success(function(data){
          return apply(data);
        }).error(function(data){
          var ref$, ref1$;
          coupon.error = (ref$ = data != null ? (ref1$ = data.errors) != null ? ref1$[0] : void 8 : void 8) != null ? ref$ : "Coupon not found";
          coupon.code = "";
          return coupon.show = true;
        });
      },
      code: ""
    };
    return {
      warning: warning,
      on: onEvent,
      handle: function($event){
        var ref$;
        debug('handle', $event);
        return coupon.code = ((ref$ = coupon.code) != null ? ref$ : "").toUpperCase();
      },
      coupon: coupon,
      adjustment: adjustment,
      addons: state.addons,
      attendees: state.attendees,
      showAttendees: function(){
        return p.join(", ")(
        p.map(function(o){
          return o.quantity + " " + o.name;
        })(
        p.filter(function(it){
          return it.quantity > 0;
        })(
        state.attendees)));
      },
      showAddons: function(){
        return p.join(", ")(
        p.map(function(o){
          return o.quantity + " " + o.name;
        })(
        p.filter(function(it){
          return it.quantity > 0;
        })(
        state.addons)));
      },
      totalWithoutTaxesfees: calcSubtotal,
      calcCoupon: calcCoupon,
      couponCode: function(){
        var code, ref$;
        code = coupon.codes[0];
        return (ref$ = code != null ? code.couponId : void 8) != null
          ? ref$
          : (ref$ = code != null ? code.name : void 8) != null ? ref$ : "UNKNOWN";
      },
      calcTaxFee: calcTaxFee,
      calcTaxesFees: calcTaxesFees,
      showPrice: showPrice,
      calcPrice: calcPrice,
      showAddonPrice: showAddonPrice,
      calcAddonPrice: calcAddonPrice,
      totalAddons: totalAddons,
      calcSubtotal: calcSubtotal,
      calcTotal: calcTotal,
      calcPreviousTotal: calcPreviousTotal,
      calcBalanceDue: calcBalanceDue
    };
  };
});
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
// Generated by LiveScript 1.4.0
angular.module('ablsdk').service('ablapi', function($xabl){
  return {
    timeslots: function(options){
      var req;
      req = $.param({
        activity: options.activityId,
        "status[event]": 'all',
        dateRange: [moment(options.startTime).clone().startOf('day').startOf('month').toISOString(), moment(options.endTime).clone().startOf('day').endOf('month').endOf('day').toISOString()]
      });
      return $xabl.get("timeslots?" + req);
    }
  };
});
// Generated by LiveScript 1.4.0
angular.module('ablsdk').service('browser', function($window){
  var name;
  name = function(){
    var userAgent, browsers, key;
    userAgent = $window.navigator.userAgent;
    browsers = {
      chrome: /chrome/i,
      safari: /safari/i,
      firefox: /firefox/i,
      ie: /msie/i
    };
    for (key in browsers) {
      if (browsers[key].test($window.navigator.userAgent)) {
        return key;
      }
    }
    return 'unknown';
  };
  return {
    name: name()
  };
});
// Generated by LiveScript 1.4.0
var toString$ = {}.toString;
angular.module('ablsdk').service('crud', function($xabl, $rootScope, debug, $mdDialog, safeApply, watcher, p){
  return function(url, initOptions){
    var parsedUrl, state, factory, provider, ref$, configureUrl, $scope, i, removeFromMemory, save, update, add, success, fetch, splice, remove, watchers, improve;
    parsedUrl = url.split('@');
    url = parsedUrl[0];
    state = {
      loading: false,
      frontendify: function(data, url){
        var parts, part, array;
        parts = url.split('/');
        part = parts[parts.length - 1];
        return array = (function(){
          switch (false) {
          case toString$.call(data).slice(8, -1) !== 'Array':
            return data;
          case toString$.call(data.list).slice(8, -1) !== 'Array':
            return data.list;
          case toString$.call(data[part]).slice(8, -1) !== 'Array':
            return data[part];
          case toString$.call(data).slice(8, -1) !== 'Object':
            return [data];
          default:
            return [];
          }
        }());
      }
    };
    factory = {
      localStorage: {
        remove: function(item){},
        add: function(item){},
        update: function(item){},
        fetch: function(item){}
      },
      memory: {
        remove: function(item){
          return removeFromMemory(item);
        },
        add: function(item, callback){
          Array.prototype.push.call(i, item);
          return typeof callback == 'function' ? callback(item) : void 8;
        },
        update: function(item, callback){
          return typeof callback == 'function' ? callback(item) : void 8;
        },
        fetch: function(){
          return state.loading = false;
        }
      },
      backend: {
        remove: function(item){
          return $xabl['delete'](url + "/" + item._id).success(function(){
            return removeFromMemory(item);
          });
        },
        update: function(item, callback){
          return $xabl.update(url + "/" + item._id, item).success(function(data){
            state.loading = false;
            return typeof callback == 'function' ? callback(data) : void 8;
          });
        },
        add: function(item, callback){
          return $xabl.create(url, item).success(function(data){
            success(data);
            return typeof callback == 'function' ? callback(data) : void 8;
          });
        },
        fetch: function(){
          var options;
          options = angular.copy(
          i.options);
          delete options.total;
          delete options.$url;
          return $xabl.get(configureUrl(url), {
            params: options
          }).success(function(data, status, headers){
            var params, r;
            i.length = 0;
            params = function(name){
              var header, parser, err;
              header = headers()[name];
              if (header != null) {
                parser = document.createElement('a');
                parser.href = headers()[name];
                try {
                  return JSON.parse('{"' + decodeURI(parser.search.substr(1, 2000)).replace(/"/g, '\\"').replace(/&/g, '","').replace(/=/g, '":"') + '"}');
                } catch (e$) {
                  err = e$;
                  console.error(err, parser.search);
                  return undefined;
                }
              } else {
                return undefined;
              }
            };
            i.options.total = (r = params('x-last-page-url'), r != null
              ? parseInt(r.page) * parseInt(r.pageSize)
              : data.length);
            i.options.pageSize = (r = params('x-first-page-url'), r != null
              ? parseInt(r.pageSize)
              : data.length);
            state.loading = false;
            return success(data);
          });
        }
      }
    };
    provider = factory[(ref$ = parsedUrl[1]) != null ? ref$ : 'backend'];
    configureUrl = function(url){
      var state, replace, u;
      state = {
        url: url
      };
      replace = function(pair){
        return state.url = state.url.replace(':' + pair[0], pair[1]);
      };
      u = i.getOptions().$url;
      if (u != null) {
        p.each(replace)(
        p.objToPairs(
        u));
      }
      return state.url;
    };
    $scope = $rootScope.$new();
    $scope.items = [];
    i = $scope.items;
    state.loading = false;
    removeFromMemory = function(item){
      var index;
      index = i.indexOf(item);
      if (index > -1) {
        return Array.prototype.splice.call(i, index, 1);
      }
    };
    save = function(item, callback){
      if (item._id != null) {
        return update(item, callback);
      } else {
        return add(item, callback);
      }
    };
    update = function(item, callback){
      if (state.loading) {
        return;
      }
      return provider.update(item, callback);
    };
    add = function(item, callback){
      if (state.loading) {
        return;
      }
      return provider.add(item, callback);
    };
    success = function(data){
      var result, type, extendObject;
      result = state.frontendify(data, url);
      type = toString$.call(result).slice(8, -1);
      switch (type) {
      case 'Array':
        Array.prototype.push.apply(i, result);
        break;
      case 'Object':
        extendObject = function(pair){
          return i[pair[0]] = pair[1];
        };
        p.each(extendObject)(
        p.objToPairs(
        result));
      }
      return state.loading = false;
    };
    i.options = {};
    i.converter = function(converter){
      state.frontendify = converter.frontendify;
      state.backendify = converter.backendify;
      return i;
    };
    i.getOptions = function(){
      return i.options;
    };
    fetch = function(options){
      if (state.loading) {
        return;
      }
      switch (toString$.call(options).slice(8, -1)) {
      case 'Function':
        i.getOptions = options;
        return fetch({});
      case 'Number':
        i.options.page = options;
        break;
      case 'Object':
        i.options = angular.extend({}, i.getOptions(), options);
      }
      state.loading = true;
      if (i.options.page != null) {
        i.options.page -= 1;
      }
      return provider.fetch();
    };
    fetch(initOptions);
    splice = function(){
      var removed;
      if (state.loading) {
        return;
      }
      removed = Array.prototype.splice.apply(i, arguments);
      return removed.forEach(provider.remove);
    };
    remove = function(item, $event, options){
      var defaultOptions, confirm;
      if (state.loading) {
        return;
      }
      defaultOptions = {
        title: "Confirm Delete",
        content: "Are you sure you want to delete this item?",
        ok: 'Confirm',
        cancel: 'Cancel'
      };
      confirm = $mdDialog.confirm({
        controller: 'confirm2',
        templateUrl: 'confirm',
        locals: {
          options: angular.extend({}, defaultOptions, options)
        },
        targetEvent: $event
      });
      return $mdDialog.show(confirm).then(function(result){
        if (result === true) {
          return provider.remove(item);
        }
      });
    };
    watchers = [];
    improve = function(source){
      var observers, bind;
      observers = [];
      bind = curry$(function(name, func){
        var bound, mutate;
        bound = [];
        improve(bound);
        mutate = function(){
          var mutated;
          mutated = Array.prototype[name].call(source, func);
          bound.length = 0;
          return Array.prototype.push.apply(bound, mutated);
        };
        observers.push(mutate);
        mutate();
        return bound;
      });
      source.loading = function(){
        return state.loading;
      };
      source.toArray = function(){
        var a;
        a = [];
        Array.prototype.push.apply(a, source);
        return a;
      };
      source.fetchOn = function(array, $scope){
        $scope.$watch(array, bind$(i, 'fetch'), true);
        return source;
      };
      source.watch = function(array, $scope){
        var func;
        func = function(){
          return safeApply(function(){
            return observers.forEach(function(it){
              return it();
            });
          });
        };
        if ($scope != null) {
          watchers.push({
            array: $scope[array],
            func: func
          });
          $scope.$watch(array, func, true);
        } else {
          watchers.push({
            array: array,
            func: func
          });
          watcher.watch(array, func);
        }
        return source;
      };
      source.watch(source);
      ['map', 'filter'].forEach(function(item){
        return source[item] = bind(item);
      });
      source.push = add;
      source.save = save;
      source.fetch = fetch;
      source.remove = remove;
      source.splice = splice;
      return source.toArray = function(){
        return angular.copy(source);
      };
    };
    i.listen = function($scope){
      $scope.$on('$destroy', function(){
        var i$, ref$, len$, item, results$ = [];
        for (i$ = 0, len$ = (ref$ = watchers).length; i$ < len$; ++i$) {
          item = ref$[i$];
          results$.push(watcher.unwatch(item.array, item.func));
        }
        return results$;
      });
      return i;
    };
    improve(i);
    return i;
  };
});
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
function bind$(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}
// Generated by LiveScript 1.4.0
angular.module('ablsdk').service('abldate', function(debug){
  return function(timeZone){
    var hack, dst;
    hack = function(input, tz){
      var d, z;
      d = bind$(moment(input), 'format');
      z = bind$(tz, 'format');
      return moment(d('YYYY-MM-DD HH:mm ') + z('Z'), "YYYY-MM-DD HH:mm Z");
    };
    dst = function(d, date){
      return d.add(moment(date).tz(timeZone).utcOffset() - d.utcOffset(), 'minute');
    };
    return {
      backendify: function(date){
        var d;
        d = hack(date, moment().tz(timeZone)).tz(timeZone);
        dst(d);
        return d.tz("UTC").format("YYYY-MM-DD\\THH:mm:ss\\Z");
      },
      frontendify: function(date){
        var d;
        d = moment(date).tz(timeZone);
        dst(d, d);
        return hack(d, moment(date)).toDate();
      }
    };
  };
});
function bind$(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}
// Generated by LiveScript 1.4.0
var toString$ = {}.toString;
angular.module('ablsdk').factory('debug', function(enabledDebug){
  return function(input){
    var mtch, ref$;
    if (enabledDebug) {
      mtch = (function(){
        switch (false) {
        case toString$.call(input != null ? input.match : void 8).slice(8, -1) !== 'Function':
          return input.match(/<<[a-z]+>>/i);
        default:
          return null;
        }
      }());
      if (mtch && window['catch'] === mtch[0].replace('<<', '').replace('>>', '')) {
        debugger;
      } else {
        switch (toString$.call(input).slice(8, -1)) {
        case 'Function':
          return input();
        default:
          return typeof console != 'undefined' && console !== null ? (ref$ = console.log) != null ? ref$.apply(console, arguments) : void 8 : void 8;
        }
      }
    }
  };
});
// Generated by LiveScript 1.4.0
angular.module('ablsdk').filter('capitalize', function(){
  return function(input){
    if (angular.isString(input) && input.length > 0) {
      return input.charAt(0).toUpperCase() + input.substr(1).toLowerCase();
    } else {
      return input;
    }
  };
}).filter('capitalizeAll', function(){
  return function(input){
    if (angular.isString(input) && input.length > 0) {
      return input.split(' ').map(function(it){
        return it.charAt(0).toUpperCase() + it.substr(1).toLowerCase();
      }).join(' ');
    } else {
      return input;
    }
  };
});
// Generated by LiveScript 1.4.0
angular.module('ablsdk').service('formula', function(p, debug){
  var getSlotPrice, getVisualPrice;
  getSlotPrice = function(type, slot){
    var arr, ref$;
    arr = (ref$ = slot != null ? slot.charges : void 8) != null
      ? ref$
      : [];
    return function(it){
      var ref$;
      return (ref$ = it != null ? it.amount : void 8) != null ? ref$ : 0;
    }(
    p.find(function(it){
      return it.type === type || it.subtype === type || it.description === type;
    })(
    arr));
  };
  getVisualPrice = function(ac){
    var ref$, merge, onlyDefault, onlyAdult, all, mergedAdults, mergedAll, mergedDefault, max, min, final;
    if ((ac != null ? (ref$ = ac.timeslots) != null ? ref$.length : void 8 : void 8) > 0) {
      merge = function(arrays){
        return [].concat.apply([], arrays);
      };
      onlyDefault = function(slot){
        var ref$;
        return p.map(function(it){
          return it.amount;
        })(
        p.filter(function(it){
          return it.status === 'active';
        })(
        p.filter(function(it){
          return it.isDefault;
        })(
        (ref$ = slot != null ? slot.charges : void 8) != null
          ? ref$
          : [])));
      };
      onlyAdult = function(slot){
        var type, ref$;
        type = 'Adult';
        return p.map(function(it){
          return it.amount;
        })(
        p.filter(function(it){
          return it.status === 'active';
        })(
        p.filter(function(it){
          return it.type === type || it.subtype === type || it.description === type;
        })(
        (ref$ = slot != null ? slot.charges : void 8) != null
          ? ref$
          : [])));
      };
      all = function(slot){
        var ref$;
        return p.map(function(it){
          return it.amount;
        })(
        p.filter(function(it){
          return it.status === 'active';
        })(
        (ref$ = slot != null ? slot.charges : void 8) != null
          ? ref$
          : []));
      };
      mergedAdults = merge(ac.timeslots.map(onlyAdult));
      mergedAll = merge(ac.timeslots.map(all));
      mergedDefault = merge(ac.timeslots.map(onlyDefault));
      max = function(array){
        return Math.max.apply(Math, array);
      };
      min = function(array){
        return Math.min.apply(Math, array);
      };
      final = (function(){
        switch (false) {
        case !(mergedDefault.length > 0):
          return min(mergedDefault);
        case !(mergedAdults.length > 0):
          return max(mergedAdults);
        case !(mergedAll.length > 0):
          return max(mergedAll);
        default:
          return 0;
        }
      }());
      return final;
    } else {
      return 'Non';
    }
  };
  return {
    getSlotPrice: function(slot){
      return getSlotPrice('Adult', slot);
    },
    getVisualPrice: getVisualPrice,
    getAdultPrice: function(ac){
      var ref$;
      return getSlotPrice('Adult', ac != null ? (ref$ = ac.timeslots) != null ? ref$[0] : void 8 : void 8);
    },
    getYouthPrice: function(ac){
      var ref$;
      return getSlotPrice('Youth', ac != null ? (ref$ = ac.timeslots) != null ? ref$[0] : void 8 : void 8);
    }
  };
});
// Generated by LiveScript 1.4.0
angular.module('ablsdk').service('ablfacade', function(ablbook, ablslot){
  return function(activity, callback){
    var book, slot;
    book = ablbook(activity, callback);
    slot = ablslot(activity, book.calendar);
    return {
      book: book,
      slot: slot
    };
  };
});
// Generated by LiveScript 1.4.0
angular.module('ablsdk').factory('prefill', function(debug, safeApply, $window){
  return function(func){
    return debug(function(){
      $window.prefill = function(){
        var params;
        params = arguments;
        return safeApply(function(){
          return func.apply(null, params);
        });
      };
      if ($window.parent != null) {
        return $window.parent.prefill = $window.prefill;
      }
    });
  };
});
// Generated by LiveScript 1.4.0
var toString$ = {}.toString;
angular.module('ablsdk').service('p', function(){
  var flatten, first;
  flatten = function(xs){
    var x;
    return [].concat.apply([], (function(){
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
        x = ref$[i$];
        if (toString$.call(x).slice(8, -1) === 'Array') {
          results$.push(flatten(x));
        } else {
          results$.push(x);
        }
      }
      return results$;
    }()));
  };
  return {
    head: first = function(xs){
      return xs[0];
    },
    each: curry$(function(f, xs){
      var i$, len$, x;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        f(x);
      }
      return xs;
    }),
    isItNaN: function(x){
      return x !== x;
    },
    all: curry$(function(f, xs){
      var i$, len$, x;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        if (!f(x)) {
          return false;
        }
      }
      return true;
    }),
    map: curry$(function(f, xs){
      return xs.map(f);
    }),
    fold: curry$(function(f, memo, xs){
      var i$, len$, x;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        memo = f(memo, x);
      }
      return memo;
    }),
    filter: curry$(function(f, xs){
      var i$, len$, x, results$ = [];
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        if (f(x)) {
          results$.push(x);
        }
      }
      return results$;
    }),
    find: curry$(function(f, xs){
      var i$, len$, x;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        if (f(x)) {
          return x;
        }
      }
    }),
    pairsToObj: function(object){
      var i$, len$, x, resultObj$ = {};
      for (i$ = 0, len$ = object.length; i$ < len$; ++i$) {
        x = object[i$];
        resultObj$[x[0]] = x[1];
      }
      return resultObj$;
    },
    objToPairs: function(object){
      var key, value, results$ = [];
      for (key in object) {
        value = object[key];
        results$.push([key, value]);
      }
      return results$;
    },
    values: function(object){
      var key, value, results$ = [];
      for (key in object) {
        value = object[key];
        results$.push(value);
      }
      return results$;
    },
    any: curry$(function(f, xs){
      var i$, len$, x;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        if (f(x)) {
          return true;
        }
      }
      return false;
    }),
    notAny: curry$(function(f, xs){
      var i$, len$, x;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        if (f(x)) {
          return false;
        }
      }
      return true;
    }),
    sum: function(xs){
      var result, i$, len$, x;
      result = 0;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        result += x;
      }
      return result;
    },
    sort: function(xs){
      return xs.concat().sort(function(x, y){
        if (x > y) {
          return 1;
        } else if (x < y) {
          return -1;
        } else {
          return 0;
        }
      });
    },
    concat: function(xss){
      return [].concat.apply([], xss);
    },
    concatMap: curry$(function(f, xs){
      var x;
      return [].concat.apply([], (function(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
          x = ref$[i$];
          results$.push(f(x));
        }
        return results$;
      }()));
    }),
    flatten: flatten,
    groupBy: curry$(function(f, xs){
      var results, i$, len$, x, key;
      results = {};
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        key = f(x);
        if (key in results) {
          results[key].push(x);
        } else {
          results[key] = [x];
        }
      }
      return results;
    }),
    sortWith: curry$(function(f, xs){
      return xs.concat().sort(f);
    }),
    sortBy: curry$(function(f, xs){
      return xs.concat().sort(function(x, y){
        if (f(x) > f(y)) {
          return 1;
        } else if (f(x) < f(y)) {
          return -1;
        } else {
          return 0;
        }
      });
    }),
    reverse: function(xs){
      return xs.concat().reverse();
    },
    split: curry$(function(sep, str){
      return str.split(sep);
    }),
    join: curry$(function(sep, xs){
      return xs.join(sep);
    }),
    lines: function(str){
      if (!str.length) {
        return [];
      }
      return str.split('\n');
    },
    unlines: function(it){
      return it.join('\n');
    },
    words: function(str){
      if (!str.length) {
        return [];
      }
      return str.split(/[ ]+/);
    },
    unwords: function(it){
      return it.join(' ');
    },
    chars: function(it){
      return it.split('');
    },
    unchars: function(it){
      return it.join('');
    },
    repeat: curry$(function(n, str){
      var result, i$;
      result = '';
      for (i$ = 0; i$ < n; ++i$) {
        result += str;
      }
      return result;
    }),
    maximum: function(xs){
      var max, i$, ref$, len$, x;
      max = xs[0];
      for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
        x = ref$[i$];
        if (x > max) {
          max = x;
        }
      }
      return max;
    },
    minimum: function(xs){
      var min, i$, ref$, len$, x;
      min = xs[0];
      for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
        x = ref$[i$];
        if (x < min) {
          min = x;
        }
      }
      return min;
    },
    maximumBy: curry$(function(f, xs){
      var max, i$, ref$, len$, x;
      max = xs[0];
      for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
        x = ref$[i$];
        if (f(x) > f(max)) {
          max = x;
        }
      }
      return max;
    }),
    minimumBy: curry$(function(f, xs){
      var min, i$, ref$, len$, x;
      min = xs[0];
      for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
        x = ref$[i$];
        if (f(x) < f(min)) {
          min = x;
        }
      }
      return min;
    }),
    capitalize: function(str){
      return str.charAt(0).toUpperCase() + str.slice(1);
    },
    camelize: function(it){
      return it.replace(/[-_]+(.)?/g, function(arg$, c){
        return (c != null ? c : '').toUpperCase();
      });
    },
    dasherize: function(str){
      return str.replace(/([^-A-Z])([A-Z]+)/g, function(arg$, lower, upper){
        return lower + "-" + (upper.length > 1
          ? upper
          : upper.toLowerCase());
      }).replace(/^([A-Z]+)/, function(arg$, upper){
        if (upper.length > 1) {
          return upper + "-";
        } else {
          return upper.toLowerCase();
        }
      });
    }
  };
});
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
// Generated by LiveScript 1.4.0
angular.module('ablsdk').filter('mdate', function(debug){
  return function(obj, mask){
    if (obj != null) {
      return obj.format(mask);
    } else {
      return null;
    }
  };
});
// Generated by LiveScript 1.4.0
var toString$ = {}.toString;
angular.module('ablsdk').service('ablslot', function(abldate, ablcalc, ablapi, formula, p, debug, $xabl, $rootScope){
  return function(activity, inputModel){
    var transformCharge, getDay, newDate, generateCalendar, getMonth, hackDate, merge, makeAvailable, defineDateStart, performChooseSlot, actualEvent, isEmpty, transformSlot, slotsByDayWithoutFilters, slotsByDay, select, isFitToSlotFull, isFitToSlot, isNotFitToAnySlot, cutoff, inPast, createMonth, startMonth, setCalendars, scroll, nextMonth, calendar, findChosenEvent, loadEvents, isDummy, isDisabledDay, selectDayAnyway, selectDay, notSelected, disabledSlot, notAvailableSlot, close, chooseSlot, chooseSlotAnyway, isActiveDay, isDisabledMonth, isActiveMonth, isCalendarUpDisabled, calendarUp, calendarDown, setup, move, eventInstanceId, createEventInstanceId, model, slots, calendars, activeSlots, possibleSlots, x$, ref$, state, observer;
    transformCharge = function(item){
      return {
        _id: item._id,
        name: item.name,
        quantity: 0,
        amount: item.amount
      };
    };
    getDay = function(date){
      var res;
      if (date != null) {
        res = (date != null ? date.format : void 8) != null
          ? date
          : moment(date);
        return parseInt(
        res.format('YYYYMMDD'));
      } else {
        return null;
      }
    };
    newDate = function(){
      var d;
      d = moment.apply(null, arguments);
      return d;
    };
    generateCalendar = function(date, callback){
      var d, year, month, toDate, lastDay, days, day, dummies;
      d = newDate(date);
      year = d.year();
      month = d.month();
      toDate = function(number){
        return newDate(moment.tz([year, month, number], activity.timeZone));
      };
      lastDay = d.endOf('month').date();
      days = p.map(toDate)(
      (function(){
        var i$, to$, results$ = [];
        for (i$ = 1, to$ = lastDay; i$ <= to$; ++i$) {
          results$.push(i$);
        }
        return results$;
      }()));
      day = newDate(days[0]).day();
      dummies = p.map(function(){
        return null;
      })(
      (function(){
        var i$, to$, results$ = [];
        for (i$ = 1, to$ = day; i$ <= to$; ++i$) {
          results$.push(i$);
        }
        return results$;
      }()));
      return {
        time: d,
        days: dummies.concat(days),
        headers: ['Su', 'M', 'Tu', 'W', 'Th', 'F', 'Sa']
      };
    };
    getMonth = function(date){
      return Math.ceil(getDay(date) / 100);
    };
    hackDate = function(input, tz){
      var d, z;
      d = bind$(moment(input), 'format');
      z = bind$(tz, 'format');
      return moment(d('YYYY-MM-DD HH:mm ') + z('Z'), "YYYY-MM-DD HH:mm Z");
    };
    merge = function(date, time){
      var ndate, ntime;
      ndate = date != null
        ? date
        : hackDate(date, moment());
      ntime = time != null
        ? time
        : hackDate(time, moment());
      return moment([ndate.year(), ndate.month(), ndate.date(), ntime.hours(), ntime.minutes(), 0]);
    };
    makeAvailable = curry$(function(slot, arg){
      var correct, quantities, available;
      correct = function(val){
        var ref$, ref1$;
        switch (false) {
        case val !== null:
          return false;
        case typeof val !== 'undefined':
          return false;
        case toString$.call(val).slice(8, -1) !== 'Number':
          return true;
        case !(toString$.call(val).slice(8, -1) === 'String' && val.length === 0):
          return false;
        case !(toString$.call(val).slice(8, -1) === 'String' && ((ref$ = val.match('^[0-9]+$')) != null ? (ref1$ = ref$[0]) != null ? ref1$.length : void 8 : void 8) === val.length):
          return true;
        default:
          return false;
        }
      };
      quantities = p.filter(correct)(
      p.map(function(it){
        return it.quantity;
      })(
      model.calc.attendees));
      available = 'inactive' === slot.status
        ? 0
        : slot.available - eval(([0].concat(quantities)).join('+'));
      return available;
    });
    defineDateStart = function(day, slot){
      var merged;
      merged = merge(day, slot.startTime);
      return model.date.start = merged;
    };
    performChooseSlot = function(slot){
      var day, transform, ref$, timeslot, attendees, makeAttendee;
      debug('perform-choose-slot', slot);
      if (slot == null) {
        throw "Slot is undefined";
      }
      if (slot.available == null) {
        throw "Slot doesn't have required 'available' field";
      }
      if (slot.available === 0) {
        return;
      }
      day = model.value;
      defineDateStart(day, slot);
      transform = abldate(activity.timeZone);
      model.date.origin = transform.backendify(model.date.start).replace(/[\:-]/ig, '');
      model.date.end = slot.endTime;
      model.title = (ref$ = slot.title) != null
        ? ref$
        : activity.title;
      model.charges = slot.charges;
      model.calc = ablcalc(slot.charges.concat(activity.charges));
      if (slot._id == null) {
        throw "Slot doesn't have required field '_id'";
      }
      model._id = slot._id;
      timeslot = p.find(function(it){
        return it._id === slot._id;
      })(
      activity.timeslots);
      if (timeslot == null) {
        throw "Slot has not been found by id " + slot._id + " in [" + activity.timeslots.map(function(it){
          return it._id;
        }).join(',') + "]";
      }
      if ((timeslot != null ? timeslot.eventId : void 8) == null) {
        throw "Event id field has not been found in timeslot " + JSON.stringify(timeslot);
      }
      model.eventId = timeslot.eventId;
      attendees = model.attendees;
      makeAttendee = function(timeslot){
        var q;
        q = attendees.filter(function(it){
          return it.name === timeslot.name;
        });
        return {
          quantity: (function(){
            switch (false) {
            case !(q.length > 0):
              return q[0].quantity;
            case timeslot.name !== 'Adult':
              return 1;
            default:
              return 0;
            }
          }()),
          name: timeslot.name,
          amount: timeslot.amount
        };
      };
      model.attendees = slot.charges.filter(function(it){
        return it.type === 'aap';
      }).map(makeAttendee);
      return model.available = makeAvailable(slot);
    };
    actualEvent = curry$(function(day, event){
      return getDay(event.startTime) === getDay(day);
    });
    isEmpty = function(day){
      return function(it){
        return it.length === 0;
      }(
      p.filter(isFitToSlot(day))(
      slots));
    };
    transformSlot = function(day){
      var actual;
      actual = actualEvent(day);
      return function(slot){
        var start, duration, event, available, ref$;
        start = merge(day, slot.startTime);
        duration = slot.endTime - slot.startTime;
        event = p.find(actual)(
        slot.events);
        available = (ref$ = event != null ? event.available : void 8) != null
          ? ref$
          : slot.maxOcc;
        debug(event != null ? event.status : void 8);
        return {
          nativeSlot: slot,
          status: event != null ? event.status : void 8,
          startTime: start,
          time: start.valueOf(),
          endTime: start.clone().add(duration, 'milliseconds'),
          charges: slot.charges,
          price: formula.getVisualPrice({
            timeslots: [slot]
          }),
          available: (event != null ? event.status : void 8) === 'inactive' ? 0 : available,
          title: event != null ? event.title : void 8,
          _id: slot._id,
          duration: moment.duration(duration).format("M[M] d[d] h[h] m[m]").replace(/((^| )0[a-z])|[ ]/ig, ''),
          taken: slot.maxOcc - available
        };
      };
    };
    slotsByDayWithoutFilters = function(day){
      return p.sortBy(function(it){
        return it.time;
      })(
      p.map(transformSlot(day))(
      p.filter(isFitToSlotFull(true, day))(
      slots)));
    };
    slotsByDay = function(day){
      return p.sortBy(function(it){
        return it.time;
      })(
      p.map(transformSlot(day))(
      p.filter(isFitToSlot(day))(
      slots)));
    };
    select = function(day){
      var pref, ref$, ref1$, ref2$, ref3$, ref4$;
      model.value = day;
      activeSlots.length = 0;
      possibleSlots.length = 0;
      slotsByDayWithoutFilters(day).forEach(function(slot){
        return possibleSlots.push(slot);
      });
      slotsByDay(day).forEach(function(slot){
        return activeSlots.push(slot);
      });
      pref = (ref$ = (ref1$ = $rootScope.user) != null ? (ref2$ = ref1$.preferences) != null ? (ref3$ = ref2$.widget) != null ? (ref4$ = ref3$.display) != null ? ref4$.timeslot : void 8 : void 8 : void 8 : void 8) != null
        ? ref$
        : {};
      if (pref.duration + pref.price + pref.availability + pref.startTime === 0 && activeSlots.length > 0) {
        return chooseSlot(activeSlots[0]);
      }
    };
    isFitToSlotFull = curry$(function(includePast, date, slot){
      var single, a, outOfActivityInterval, today, inPast, day, outOfWeek, check;
      single = slot.daysRunning.length === 0;
      a = activity;
      outOfActivityInterval = (function(){
        switch (false) {
        case !single:
          return getDay(slot.startTime) !== getDay(date);
        case !(getDay(slot.untilTime) < getDay(date)):
          return true;
        case !(getDay(slot.startTime) > getDay(date)):
          return true;
        default:
          return false;
        }
      }());
      today = merge(date, slot.startTime);
      inPast = today.diff(newDate(), 'minutes') - cutoff;
      day = function(date){
        var d, _;
        d = date != null ? typeof date.day == 'function' ? date.day() : void 8 : void 8;
        return _ = (function(){
          switch (false) {
          case d !== null:
            return null;
          case d !== 0:
            return 6;
          default:
            return d - 1;
          }
        }());
      };
      outOfWeek = !single && p.notAny(function(it){
        return it === day(date);
      })(
      slot.daysRunning);
      check = (function(){
        switch (false) {
        case !outOfWeek:
          return false;
        case !outOfActivityInterval:
          return false;
        case !(inPast <= 0):
          return false;
        default:
          return true;
        }
      }());
      return check;
    });
    isFitToSlot = isFitToSlotFull(false);
    isNotFitToAnySlot = function(date){
      switch (false) {
      case !p.notAny(function(it){
        return it.available > 0;
      })(
      slotsByDay(date)):
        return true;
      case !p.notAny(isFitToSlot(date))(
        slots):
        return true;
      default:
        return false;
      }
    };
    cutoff = (function(){
      var ref$, ref1$, ref2$, ref3$, ref4$, ref5$;
      switch (false) {
      case ((ref$ = $rootScope.user) != null ? (ref1$ = ref$.preferences) != null ? (ref2$ = ref1$.widget) != null ? (ref3$ = ref2$.display) != null ? (ref4$ = ref3$.event) != null ? ref4$.isSiteWide : void 8 : void 8 : void 8 : void 8 : void 8) !== true:
        return $rootScope.user.preferences.widget.display.event.cutoff;
      case !(((ref5$ = activity.cutoff) != null
          ? ref5$
          : -1) > -1):
        return activity.cutoff;
      default:
        return 48 * 60;
      }
    }());
    inPast = function(date, flags){
      if (flags != null && flags.indexOf('include_nearest') > -1) {
        return getDay(date) < getDay(newDate());
      } else {
        return getDay(date) < getDay(newDate());
      }
    };
    createMonth = function(date){
      return newDate([date.year(), date.month(), 15]);
    };
    startMonth = createMonth(newDate());
    setCalendars = function(f, s, callback){
      calendars.length = 0;
      calendars.push(f);
      calendars.push(s);
      return loadEvents(callback);
    };
    scroll = {
      activeDate: function(){
        var start, up, get, isActive, scrollTo, active;
        scroll.activeDate = function(){};
        start = calendars[0];
        up = function(step){
          return generateCalendar(start.time.clone().add(step, 'month'));
        };
        get = function(step){
          if (step === 0) {
            return start;
          } else {
            return up(step);
          }
        };
        isActive = function(step){
          return typeof p.find(function(it){
            return !isDisabledDay(it);
          })(
          get(step).days) !== 'undefined';
        };
        scrollTo = function(i){
          return (function(){
            var i$, to$, results$ = [];
            for (i$ = 1, to$ = i; i$ <= to$; ++i$) {
              results$.push(i$);
            }
            return results$;
          }()).forEach(bind$(calendar, 'down'));
        };
        active = p.find(isActive)(
        [0, 1, 2, 3, 4, 5, 6]);
        if (active > 0) {
          return scrollTo(active);
        }
      }
    };
    nextMonth = function(d, x){
      return date.clone().add(x, 'months');
    };
    calendar = {
      first: startMonth,
      second: startMonth.clone().add(1, 'months'),
      move: function(direction){
        calendar.first = calendar.first.clone().add(direction, 'month');
        calendar.second = calendar.second.clone().add(direction, 'month');
        return setCalendars(generateCalendar(calendar.first), generateCalendar(calendar.second));
      },
      down: function(){
        return calendar.move(1);
      },
      up: function(){
        return calendar.move(-1);
      }
    };
    findChosenEvent = function(){
      var ref$, pairs, id, dateTransform, day, slot, visualSlot;
      if (((ref$ = state.chosenEvent) != null ? ref$ : "").length === 0) {
        return;
      }
      if (slots.length === 0) {
        return;
      }
      pairs = state.chosenEvent.split('_');
      id = pairs[0];
      dateTransform = abldate(activity.timeZone);
      day = moment(dateTransform.frontendify(moment(pairs[1], 'YYYYMMDDHHmmssZ').toDate()));
      slot = p.find(function(it){
        return it.eventId === id;
      })(
      slots);
      if (slot != null) {
        if (!isDisabledDay(day)) {
          selectDay(day);
          debug({
            activeSlots: activeSlots,
            possibleSlots: possibleSlots,
            currentSlot: slot._id
          });
          slot = p.find(function(it){
            return it._id === slot._id;
          })(
          activeSlots);
          if (slot != null) {
            return chooseSlot(
            slot);
          } else {
            return observer.notify('event-not-found');
          }
        } else {
          visualSlot = p.find(function(it){
            return it._id === slot._id;
          })(
          slotsByDay(day));
          if (slot == null) {
            observer.notify('event-not-found');
          }
          if (notAvailableSlot(visualSlot)) {
            return observer.notify('event-sold-out');
          } else if (inPast(day)) {
            return observer.notify('event-too-close');
          } else {
            return observer.notify('event-not-found');
          }
        }
      } else {
        return observer.notify('event-not-found');
      }
    };
    loadEvents = function(callback){
      return ablapi.timeslots({
        startTime: calendars[0].time,
        endTime: calendars[1].time,
        activityId: activity._id
      }).success(function(loadedSlots){
        var transform, comp, transformDate;
        transform = abldate(activity.timeZone);
        comp = compose$(transform.frontendify, moment);
        transformDate = function(slot){
          slot.startTime = comp(slot.startTime);
          slot.endTime = comp(slot.endTime);
          slot.untilTime = comp(slot.untilTime);
          return slot;
        };
        slots.length = 0;
        loadedSlots.list.map(transformDate).forEach(function(item){
          return slots.push(item);
        });
        findChosenEvent();
        scroll.activeDate();
        return typeof callback == 'function' ? callback() : void 8;
      });
    };
    isDummy = function(date){
      switch (false) {
      case date !== null:
        return true;
      default:
        return false;
      }
    };
    isDisabledDay = function(date, flags){
      switch (false) {
      case !isDummy(date):
        return true;
      case !isEmpty(date):
        return true;
      case !inPast(date, flags):
        return true;
      case !isNotFitToAnySlot(date):
        return true;
      default:
        return false;
      }
    };
    selectDayAnyway = function(day){
      select(day);
      return defineDateStart(day, slots[0]);
    };
    selectDay = function(day){
      if (isDisabledDay(day)) {
        return;
      }
      return selectDayAnyway(day);
    };
    notSelected = function(){
      switch (false) {
      case model.date.start !== null:
        return true;
      case model.chosen !== false:
        return true;
      default:
        return false;
      }
    };
    disabledSlot = function(slot){
      switch (false) {
      case slot.available !== 0:
        return "This event is full";
      default:
        return "";
      }
    };
    notAvailableSlot = function(slot){
      return slot.available <= 0;
    };
    close = function(chosen){
      var setDefault;
      setDefault = function(attendee){
        if (attendee.quantity === 0 && attendee.name === 'Adult') {
          return attendee.quantity = 1;
        }
      };
      model.attendees.forEach(setDefault);
      model.chosen = chosen;
      model.visible = false;
      return typeof model.closed == 'function' ? model.closed(chosen) : void 8;
    };
    chooseSlot = function(slot){
      if (notAvailableSlot(slot)) {
        return;
      }
      performChooseSlot(slot);
      return close(true);
    };
    chooseSlotAnyway = function(slot){
      performChooseSlot(slot);
      return close(true);
    };
    isActiveDay = function(date){
      return getDay(date) === getDay(model.value);
    };
    isDisabledMonth = function(date){
      switch (false) {
      case !(getDay(date) < getDay(newDate())):
        return true;
      default:
        return false;
      }
    };
    isActiveMonth = function(date){
      return getMonth(date) === getMonth(model.value);
    };
    isCalendarUpDisabled = function(){
      return getMonth(calendars[0].time) < getMonth(newDate());
    };
    calendarUp = function(){
      if (isCalendarUpDisabled()) {
        return;
      }
      return calendar.up();
    };
    calendarDown = function(){
      return calendar.down();
    };
    setup = function(){
      return setCalendars(generateCalendar(startMonth.clone()), generateCalendar(startMonth.clone().add(1, 'month')), function(){
        return selectDay(model.value);
      });
    };
    move = function(bookingId){
      return $xabl.put("bookings/" + bookingId + "/move", {
        eventInstanceId: createEventInstanceId()
      });
    };
    eventInstanceId = function(model){
      var transform;
      transform = abldate(activity.timeZone);
      return model.eventId + '_' + transform.backendify(model.date.start).replace(/[\:-]/ig, '');
    };
    createEventInstanceId = function(){
      return eventInstanceId(model);
    };
    model = inputModel != null
      ? inputModel
      : {};
    slots = [];
    calendars = [];
    activeSlots = [];
    possibleSlots = [];
    x$ = model;
    x$.date = {
      start: null,
      end: null
    };
    x$.value = null;
    x$.eventId = null;
    x$._id = null;
    x$.charges = [];
    x$.attendees = [];
    x$.addons = activity.charges.filter(function(it){
      return it.type === 'addon';
    }).map(transformCharge);
    x$.questions = (ref$ = activity.questions) != null
      ? ref$
      : [];
    x$.bg = activity.image;
    setup();
    state = {
      chosenEvent: null
    };
    observer = {
      list: [],
      observe: function(func){
        return observer.list.push(func);
      },
      notify: function(name, data){
        return p.each(function(watch){
          return watch(name, data);
        })(
        observer.list);
      }
    };
    return {
      observe: observer.observe,
      chooseEvent: function(id){
        state.chosenEvent = id;
        return findChosenEvent();
      },
      model: model,
      activeSlots: activeSlots,
      possibleSlots: possibleSlots,
      move: move,
      selectDay: selectDay,
      selectDayAnyway: selectDayAnyway,
      calendars: calendars,
      createEventInstanceId: createEventInstanceId,
      calendarUp: calendarUp,
      calendarDown: calendarDown,
      close: close,
      isActiveMonth: isActiveMonth,
      isDisabledDay: isDisabledDay,
      isDisabledMonth: isDisabledMonth,
      isCalendarUpDisabled: isCalendarUpDisabled,
      isDummy: isDummy,
      isActiveDay: isActiveDay,
      notSelected: notSelected,
      chooseSlot: chooseSlot,
      chooseSlotAnyway: chooseSlotAnyway,
      notAvailableSlot: notAvailableSlot,
      disabledSlot: disabledSlot
    };
  };
});
function bind$(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
function compose$() {
  var functions = arguments;
  return function() {
    var i, result;
    result = functions[0].apply(this, arguments);
    for (i = 1; i < functions.length; ++i) {
      result = functions[i](result);
    }
    return result;
  };
}
// Generated by LiveScript 1.4.0
angular.module('ablsdk').factory('stripe', function($rootScope, safeApply){
  var model, init;
  model = {};
  init = function(){
    var c;
    model.setPublishableKey = Stripe.setPublishableKey;
    c = Stripe.card;
    return model.createToken = function(card, callback){
      var ref$, ref1$, ref2$, ref3$;
      if (!c.validateCardNumber(card.number)) {
        return callback('Card number is not correct');
      }
      if (!c.validateExpiry(card.exp_month, card.exp_year)) {
        return callback('Expiration Month/Year is not correct');
      }
      if (!c.validateCVC(card.cvc)) {
        return callback('CVV is not correct. Your CVV number can be located by looking on your credit or debit card');
      }
      return c.createToken({
        number: card.number,
        cvc: card.cvc,
        exp_month: card.exp_month,
        exp_year: card.exp_year,
        name: card.fullName,
        address_line1: (ref$ = card.location) != null ? ref$.street_address : void 8,
        address_city: (ref1$ = card.location) != null ? ref1$.city : void 8,
        address_country: (ref2$ = card.location) != null ? ref2$.country : void 8,
        address_state: (ref3$ = card.location) != null ? ref3$.state : void 8
      }, function(status, resp){
        if (resp.id != null) {
          return safeApply(function(){
            return callback(null, resp.id);
          });
        } else {
          return safeApply(function(){
            return callback(resp.error.message);
          });
        }
      });
    };
  };
  if (typeof window.Stripe === 'undefined') {
    throw 'please add <script src="https://js.stripe.com/v2/"></script>';
  } else {
    init();
  }
  return model;
});
// Generated by LiveScript 1.4.0
angular.module('ablsdk').service('test', function(debug){
  return function(input){
    return debug(function(){
      var test;
      test = input();
      if (test !== true) {
        throw "[FAILED TEST]" + input.toString();
      }
    });
  };
});
// Generated by LiveScript 1.4.0
var toString$ = {}.toString;
angular.module('ablsdk').service('typecheck', function(debug, p){
  var buildParseType, buildParsedTypeCheck, parseType, parsedTypeCheck;
  buildParseType = function(){
    var identifierRegex, tokenRegex;
    identifierRegex = /[\$\w]+/;
    function peek(tokens){
      var token;
      token = tokens[0];
      if (token == null) {
        throw new Error('Unexpected end of input.');
      }
      return token;
    }
    function consumeIdent(tokens){
      var token;
      token = peek(tokens);
      if (!identifierRegex.test(token)) {
        throw new Error("Expected text, got '" + token + "' instead.");
      }
      return tokens.shift();
    }
    function consumeOp(tokens, op){
      var token;
      token = peek(tokens);
      if (token !== op) {
        throw new Error("Expected '" + op + "', got '" + token + "' instead.");
      }
      return tokens.shift();
    }
    function maybeConsumeOp(tokens, op){
      var token;
      token = tokens[0];
      if (token === op) {
        return tokens.shift();
      } else {
        return null;
      }
    }
    function consumeArray(tokens){
      var types;
      consumeOp(tokens, '[');
      if (peek(tokens) === ']') {
        throw new Error("Must specify type of Array - eg. [Type], got [] instead.");
      }
      types = consumeTypes(tokens);
      consumeOp(tokens, ']');
      return {
        structure: 'array',
        of: types
      };
    }
    function consumeTuple(tokens){
      var components;
      components = [];
      consumeOp(tokens, '(');
      if (peek(tokens) === ')') {
        throw new Error("Tuple must be of at least length 1 - eg. (Type), got () instead.");
      }
      for (;;) {
        components.push(consumeTypes(tokens));
        maybeConsumeOp(tokens, ',');
        if (')' === peek(tokens)) {
          break;
        }
      }
      consumeOp(tokens, ')');
      return {
        structure: 'tuple',
        of: components
      };
    }
    function consumeFields(tokens){
      var fields, subset, ref$, key, types;
      fields = {};
      consumeOp(tokens, '{');
      subset = false;
      for (;;) {
        if (maybeConsumeOp(tokens, '...')) {
          subset = true;
          break;
        }
        ref$ = consumeField(tokens), key = ref$[0], types = ref$[1];
        fields[key] = types;
        maybeConsumeOp(tokens, ',');
        if ('}' === peek(tokens)) {
          break;
        }
      }
      consumeOp(tokens, '}');
      return {
        structure: 'fields',
        of: fields,
        subset: subset
      };
    }
    function consumeField(tokens){
      var key, types;
      key = consumeIdent(tokens);
      consumeOp(tokens, ':');
      types = consumeTypes(tokens);
      return [key, types];
    }
    function maybeConsumeStructure(tokens){
      switch (tokens[0]) {
      case '[':
        return consumeArray(tokens);
      case '(':
        return consumeTuple(tokens);
      case '{':
        return consumeFields(tokens);
      }
    }
    function consumeType(tokens){
      var token, wildcard, type, structure;
      token = peek(tokens);
      wildcard = token === '*';
      if (wildcard || identifierRegex.test(token)) {
        type = wildcard
          ? consumeOp(tokens, '*')
          : consumeIdent(tokens);
        structure = maybeConsumeStructure(tokens);
        if (structure) {
          return structure.type = type, structure;
        } else {
          return {
            type: type
          };
        }
      } else {
        structure = maybeConsumeStructure(tokens);
        if (!structure) {
          throw new Error("Unexpected character: " + token);
        }
        return structure;
      }
    }
    function consumeTypes(tokens){
      var lookahead, types, typesSoFar, typeObj, type;
      if ('::' === peek(tokens)) {
        throw new Error("No comment before comment separator '::' found.");
      }
      lookahead = tokens[1];
      if (lookahead != null && lookahead === '::') {
        tokens.shift();
        tokens.shift();
      }
      types = [];
      typesSoFar = {};
      if ('Maybe' === peek(tokens)) {
        tokens.shift();
        types = [
          {
            type: 'Undefined'
          }, {
            type: 'Null'
          }
        ];
        typesSoFar = {
          Undefined: true,
          Null: true
        };
      }
      for (;;) {
        typeObj = consumeType(tokens), type = typeObj.type;
        if (!typesSoFar[type]) {
          types.push(typeObj);
        }
        typesSoFar[type] = true;
        if (!maybeConsumeOp(tokens, '|')) {
          break;
        }
      }
      return types;
    }
    tokenRegex = RegExp('\\.\\.\\.|::|->|' + identifierRegex.source + '|\\S', 'g');
    return function(input){
      var tokens, e;
      if (!input.length) {
        throw new Error('No type specified.');
      }
      tokens = input.match(tokenRegex) || [];
      if (in$('->', tokens)) {
        throw new Error("Function types are not supported.\ To validate that something is a function, you may use 'Function'.");
      }
      try {
        return consumeTypes(tokens);
      } catch (e$) {
        e = e$;
        throw new Error(e.message + " - Remaining tokens: " + JSON.stringify(tokens) + " - Initial input: '" + input + "'");
      }
    };
  };
  buildParsedTypeCheck = function(){
    var any, all, isItNaN, types, defaultType, customTypes;
    any = p.any;
    all = p.all;
    isItNaN = p.isItNaN;
    types = {
      Number: {
        typeOf: 'Number',
        validate: function(it){
          return !isItNaN(it);
        }
      },
      NaN: {
        typeOf: 'Number',
        validate: isItNaN
      },
      Int: {
        typeOf: 'Number',
        validate: function(it){
          return !isItNaN(it) && it % 1 === 0;
        }
      },
      Float: {
        typeOf: 'Number',
        validate: function(it){
          return !isItNaN(it);
        }
      },
      Date: {
        typeOf: 'Date',
        validate: function(it){
          return !isItNaN(it.getTime());
        }
      }
    };
    defaultType = {
      array: 'Array',
      tuple: 'Array'
    };
    function checkArray(input, type){
      return all(function(it){
        return checkMultiple(it, type.of);
      }, input);
    }
    function checkTuple(input, type){
      var i, i$, ref$, len$, types;
      i = 0;
      for (i$ = 0, len$ = (ref$ = type.of).length; i$ < len$; ++i$) {
        types = ref$[i$];
        if (!checkMultiple(input[i], types)) {
          return false;
        }
        i++;
      }
      return input.length <= i;
    }
    function checkFields(input, type){
      var inputKeys, numInputKeys, k, numOfKeys, key, ref$, types;
      inputKeys = {};
      numInputKeys = 0;
      for (k in input) {
        inputKeys[k] = true;
        numInputKeys++;
      }
      numOfKeys = 0;
      for (key in ref$ = type.of) {
        types = ref$[key];
        if (!checkMultiple(input[key], types)) {
          return false;
        }
        if (inputKeys[key]) {
          numOfKeys++;
        }
      }
      return type.subset || numInputKeys === numOfKeys;
    }
    function checkStructure(input, type){
      if (!(input instanceof Object)) {
        return false;
      }
      switch (type.structure) {
      case 'fields':
        return checkFields(input, type);
      case 'array':
        return checkArray(input, type);
      case 'tuple':
        return checkTuple(input, type);
      }
    }
    function check(input, typeObj){
      var type, structure, setting, that;
      type = typeObj.type, structure = typeObj.structure;
      if (type) {
        if (type === '*') {
          return true;
        }
        setting = customTypes[type] || types[type];
        if (setting) {
          return setting.typeOf === toString$.call(input).slice(8, -1) && setting.validate(input);
        } else {
          return type === toString$.call(input).slice(8, -1) && (!structure || checkStructure(input, typeObj));
        }
      } else if (structure) {
        if (that = defaultType[structure]) {
          if (that !== toString$.call(input).slice(8, -1)) {
            return false;
          }
        }
        return checkStructure(input, typeObj);
      } else {
        throw new Error("No type defined. Input: " + input + ".");
      }
    }
    function checkMultiple(input, types){
      if (toString$.call(types).slice(8, -1) !== 'Array') {
        throw new Error("Types must be in an array. Input: " + input + ".");
      }
      return any(function(it){
        return check(input, it);
      }, types);
    }
    return function(parsedType, input, options){
      options == null && (options = {});
      customTypes = options.customTypes || {};
      return checkMultiple(input, parsedType);
    };
  };
  parseType = buildParseType();
  parsedTypeCheck = buildParsedTypeCheck();
  return function(type, input, options){
    return debug(function(){
      var result;
      result = parsedTypeCheck(parseType(type), input, options);
      if (!result) {
        return console.error("Type doesn't match with object", type, input);
      }
    });
  };
});
function in$(x, xs){
  var i = -1, l = xs.length >>> 0;
  while (++i < l) if (x === xs[i]) return true;
  return false;
}
// Generated by LiveScript 1.4.0
angular.module('ablsdk').service('watcher', function($rootScope, browser, debug){
  var ugly, standard, r;
  ugly = function(){
    return {
      unwatch: function(array, func){
        return typeof func.unwatch == 'function' ? func.unwatch() : void 8;
      },
      watch: function(array, func){
        var $scope;
        $scope = $rootScope.$new();
        $scope.array = array;
        return func.unwatch = $scope.$watch('array', func, true);
      }
    };
  };
  standard = function(){
    return {
      unwatch: function(array, func){
        return Array.unobserve(array, func);
      },
      watch: function(array, callback){
        var createWatch, watch, ref$;
        createWatch = function(){
          var n;
          n = $rootScope.$new();
          return function(array, func){
            n.array = array;
            return n.$watch('array', func);
          };
        };
        watch = (ref$ = Array.observe) != null
          ? ref$
          : createWatch();
        return watch(array, callback);
      }
    };
  };
  r = (function(){
    switch (false) {
    case browser.name !== 'firefox':
      return ugly();
    case browser.name !== 'unknown':
      return ugly();
    case browser.name !== 'safari':
      return ugly();
    default:
      return ugly();
    }
  }());
  return r;
});
// Generated by LiveScript 1.4.0
angular.module('ablsdk').directive('event', function(p, safeApply){
  return {
    restrict: 'A',
    scope: {
      event: '&'
    },
    link: function($scope, element, $attrs){
      var $element, setup;
      $element = $(element);
      setup = function(eventName){
        return $element[eventName](function(event){
          var apply;
          apply = function(){
            return $scope.event({
              event: event
            });
          };
          return safeApply(apply, $scope);
        });
      };
      return p.each(setup)(
      ['blur', 'focus', 'keyup']);
    }
  };
});
// Generated by LiveScript 1.4.0
angular.module('ablsdk').filter('price', function($filter){
  return function(amount, config){
    var view, r;
    view = amount / 100;
    return r = (function(){
      switch (false) {
      case config !== '00.00$':
        return $filter('currency')(view).replace("$", '').trim() + "$";
      case config !== "$00":
        return '$' + Math.round(view);
      default:
        return $filter('currency')(view);
      }
    }());
  };
});
// Generated by LiveScript 1.4.0
angular.module('ablsdk').service('safeApply', function($rootScope){
  return function(fn, $scope){
    var $current, phase;
    $current = $scope != null ? $scope : $rootScope;
    phase = $current.$$phase;
    if (phase === '$apply' || phase === '$digest') {
      return fn();
    } else {
      return $current.$apply(fn);
    }
  };
});
