// Generated by LiveScript 1.3.1
angular.module('ablsdk', []);
// Generated by LiveScript 1.3.1
angular.module('ablsdk').service('ablapi', function($xabl){
  return {
    timeslots: function(options){
      var req;
      req = $.param({
        activity: options.activityId,
        "status[event]": 'all',
        dateRange: [moment(options.startTime).clone().startOf('day').startOf('month').toISOString(), moment(options.endTime).clone().startOf('day').endOf('month').endOf('day').toISOString()]
      });
      return $xabl.get("timeslots?" + req);
    }
  };
});
// Generated by LiveScript 1.3.1
angular.module('ablsdk').service('ablbook', function($xabl, p, stripe, debug, prefill){
  return function(activity, globalCallback){
    var state, getDay, investigateDate, valid, issue, error, closeError, typing, resetIdenpotencyKey, few, sum, disabledOrder, cardify, expDateChanged, getEventInstanceId, cardChanged, stripeProcess, paymentSetup, validate, checkout, agree, isError, showError, fields, tryCheckout, message, placeholder, x$;
    state = {
      triedCheckout: false,
      typing: '',
      braintreeClient: null,
      loading: false,
      idenpotencyKey: null,
      form: {
        error: "",
        agreed: false,
        email: '',
        name: '',
        phone: '',
        address: '',
        location: {},
        notes: '',
        date: {
          start: null,
          end: null
        },
        creditCard: {
          card: '',
          expDate: '',
          cvv: ''
        }
      },
      calendar: {
        value: null,
        visible: false,
        currentActivity: activity,
        closed: function(chosen){
          state.form.date.start = state.calendar.date.start;
          state.form.date.end = state.calendar.date.end;
          return globalCallback('slot-chosen', chosen);
        }
      }
    };
    getDay = function(date){
      var res;
      if (date != null) {
        res = (date != null ? date.format : void 8) != null
          ? date
          : moment(date);
        return parseInt(
        res.format('YYYYMMDD'));
      } else {
        return null;
      }
    };
    investigateDate = function(bag){
      var _;
      return _ = (function(){
        switch (false) {
        case bag.start !== null:
          return 'none';
        case getDay(bag.start) === getDay(bag.end):
          return 'different';
        default:
          return 'same';
        }
      }());
    };
    valid = function(form){
      return !state.loading && form.$valid;
    };
    issue = function(form){
      var field, text;
      for (field in fields) {
        if (fields.hasOwnProperty(field)) {
          text = message(form, field);
          if ((text != null ? text.length : void 8) > 0) {
            return text;
          }
        }
      }
      return "Please check the form";
    };
    error = function(message){
      return state.form.error = message;
    };
    closeError = function(){
      return error("");
    };
    typing = function(name){
      state.triedCheckout = false;
      return state.typingInput = name;
    };
    resetIdenpotencyKey = function(){
      var s;
      return state.idenpotencyKey = (s = function(){
        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
      }, s() + s() + '-' + s() + '-' + s() + '-' + s() + '-' + s() + s() + s());
    };
    resetIdenpotencyKey();
    few = function(arr){
      var ref$;
      return (ref$ = arr != null ? typeof arr.filter == 'function' ? arr.filter(function(it){
        return it.quantity > 0;
      }) : void 8 : void 8) != null
        ? ref$
        : [];
    };
    sum = function(arr){
      switch (false) {
      case typeof arr !== 'undefined':
        return 0;
      case typeof arr !== null:
        return 0;
      case arr.length !== 0:
        return 0;
      default:
        return arr.reduce(function(x, y){
          return x + y;
        });
      }
    };
    disabledOrder = function(){
      return sum(state.calendar.calc.attendees.map(function(it){
        return it.quantity;
      })) === 0;
    };
    cardify = function(val, val2){
      var newval;
      newval = (function(){
        switch (false) {
        case val.length !== 4:
          return val + " ";
        case val.length !== 9:
          return val + " ";
        case val.length !== 14:
          return val + " ";
        case val.length !== 19:
          return val + " ";
        default:
          return val;
        }
      }());
      return newval + val2;
    };
    expDateChanged = function(){
      var value, e, ref$, t;
      value = event.target.value;
      e = (ref$ = value != null ? value.replace('/', '') : void 8) != null ? ref$ : "";
      t = function(it){
        return it != null ? it : "";
      };
      return state.form.creditCard.expDate = (function(){
        switch (false) {
        case e.length !== 2:
          return e[0] + e[1] + '/';
        case !(e.length > 2):
          return e[0] + e[1] + '/' + t(e[2]) + t(e[3]);
        default:
          return e;
        }
      }());
    };
    getEventInstanceId = function(){
      var eventId;
      eventId = activity.timeslots.filter(function(it){
        return it._id === state.calendar._id;
      })[0].eventId;
      return eventId + '_' + state.calendar.date.origin;
    };
    cardChanged = function(event){
      var value;
      value = event.target.value;
      if (typeof value === 'undefined') {
        return;
      }
      return state.form.creditCard.card = function(it){
        return it.substr(0, 19);
      }(
      p.fold(cardify, "")(
      function(it){
        return it.split(' ').join('');
      }(
      value)));
    };
    stripeProcess = function(key, callback){
      var cc, expDate, f, req;
      if (typeof key === 'undefined') {
        state.loading = false;
        return error("Stripe key is not defined");
      }
      stripe.setPublishableKey(key);
      cc = state.form.creditCard;
      expDate = cc.expDate.split('/');
      f = state.form;
      req = {
        number: cc.card,
        cvc: cc.cvv,
        exp_month: expDate[0],
        exp_year: "20" + expDate[1],
        fullName: f.name,
        location: f.location,
        state: f.state
      };
      return stripe.createToken(req, function(err, token){
        var a, makeNulls, req;
        if (err != null) {
          state.loading = false;
          return error(err);
        }
        a = activity;
        makeNulls = function(total){
          return p.map(function(){
            return null;
          })(
          (function(){
            var i$, to$, results$ = [];
            for (i$ = 1, to$ = total; i$ <= to$; ++i$) {
              results$.push(i$);
            }
            return results$;
          }()));
        };
        debug(state.calendar.calc.attendees);
        req = {
          stripeToken: token,
          couponId: state.calendar.calc.coupon.codes.length > 0 ? state.calendar.calc.coupon.codes[0].couponId : undefined,
          paymentMethod: 'credit',
          eventInstanceId: getEventInstanceId(),
          addons: p.pairsToObj(
          p.map(function(a){
            return [a._id, makeNulls(a.quantity)];
          })(
          state.calendar.calc.addons)),
          attendees: p.pairsToObj(
          p.map(function(a){
            return [a._id, makeNulls(a.quantity)];
          })(
          state.calendar.calc.attendees)),
          answers: p.pairsToObj(
          p.map(function(a){
            return [a._id, a.answer];
          })(
          state.calendar.questions)),
          adjustments: state.calendar.calc.adjustment.list,
          fullName: f.name,
          email: f.email,
          phoneNumber: f.phone,
          notes: f.notes,
          location: f.location,
          currency: 'usd',
          _customHeaders: {
            "Idempotency-Key": state.idenpotencyKey
          }
        };
        return $xabl.post('bookings', req).success(function(data){
          var ref$, ref1$;
          if (data.bookingId != null) {
            resetIdenpotencyKey();
            return callback(data);
          } else {
            return error((ref$ = (ref1$ = e.errors) != null ? ref1$[0] : void 8) != null ? ref$ : "Server error");
          }
        }).error(function(e){
          var ref$, ref1$;
          return error((ref$ = (ref1$ = e.errors) != null ? ref1$[0] : void 8) != null ? ref$ : "Server error");
        })['finally'](function(){
          return state.loading = false;
        });
      });
    };
    paymentSetup = function(){
      return $xabl.get('payments/setup');
    };
    validate = function(form){
      debug('validate');
      if (state.loading === true) {
        return;
      }
      state.triedCheckout = true;
      if (!valid(form)) {
        return error(issue(form));
      }
    };
    checkout = function(form){
      if (state.loading === true) {
        return;
      }
      state.triedCheckout = true;
      if (valid(form)) {
        state.loading = true;
        return paymentSetup().success(function(data){
          return stripeProcess(data.publicKey, function(booking){
            state.booking = booking;
            return globalCallback('success', booking);
          });
        }).error(function(err){
          state.loading = false;
          error(err);
          return globalCallback('error', error);
        });
      } else {
        return error(issue(form));
      }
    };
    agree = function(){
      state.form.agreed = !state.form.agreed;
      return tryCheckout();
    };
    isError = function(v){
      return v.required || v.pattern || v.minlength || v.maxlength || v.phone;
    };
    showError = function(name, v){
      var ref$, ref1$, ref2$;
      switch (false) {
      case !v.required:
        return (ref$ = (ref1$ = fields[name]) != null ? (ref2$ = ref1$.message) != null ? ref2$.required : void 8 : void 8) != null
          ? ref$
          : name + " is required";
      case !v.pattern:
        return "Please follow the example " + fields[name].example;
      case !v.minlength:
        return name + " is too short";
      case !v.maxlength:
        return name + " is too long";
      case !v.phone:
        return name + " is not valid phone number";
      default:
        return "please check " + name;
      }
    };
    fields = {
      email: {
        pattern: /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$/i,
        example: 'nickname@email.com',
        placeholder: 'Email'
      },
      name: {
        pattern: '',
        example: 'Your name',
        placeholder: 'Name'
      },
      phone: {
        pattern: /^[0-9]{3}[-][0-9]{3}[-][0-9]{3,5}$/i,
        placeholder: "Phone +1 123-456-1234",
        example: "+1 123-456-1234"
      },
      address: {
        pattern: '',
        example: 'Address',
        placeholder: 'Home address'
      },
      notes: {
        pattern: '',
        example: "Notes",
        placeholder: "Notes"
      },
      card: {
        pattern: /[0-9]{4} [0-9]{4} [0-9]{4} [0-9]{4}/i,
        example: '0000 0000 0000 0000',
        placeholder: "Credit Card Number"
      },
      expDate: {
        pattern: /[0-9]{2}\/[0-9]{2}/i,
        example: "05/15",
        placeholder: 'Exp Date (MM/DD)'
      },
      startDate: {},
      cvv: {
        pattern: /[0-9]{3,4}/i,
        example: "000",
        placeholder: "CVV"
      },
      agreed: {
        pattern: 'true',
        message: {
          required: "Please accept the terms and conditions"
        }
      }
    };
    tryCheckout = function(){
      if (state.form.agreed) {
        return state.triedCheckout = true;
      }
    };
    message = function(form, name){
      var field, val, ref$, ref1$, ref2$, ref3$, ref4$;
      if (state.triedCheckout === true) {
        for (field in fields) {
          if (fields.hasOwnProperty(field)) {
            val = (ref$ = form[field]) != null ? ref$.$error : void 8;
            if (val && isError(val)) {
              if (field === name) {
                return showError(field, val);
              }
              return "";
            }
          }
        }
        return "";
      } else {
        for (field in fields) {
          if (fields.hasOwnProperty(field)) {
            val = (ref1$ = form[field]) != null ? ref1$.$error : void 8;
            if (val && isError(val) && val.maxlength) {
              if (field === name) {
                return showError(field, val);
              }
              return "";
            }
          }
        }
        if (state.typingInput === name) {
          if (((ref2$ = form[name]) != null ? (ref3$ = ref2$.$error) != null ? ref3$.pattern : void 8 : void 8) != null && ((ref4$ = fields[name].example) != null ? ref4$.length : void 8) > 0) {
            return "";
            return "example: " + fields[name].example;
          }
        }
      }
    };
    placeholder = function(name){
      if (state.typingInput === name) {
        return fields[name].example;
      } else {
        return fields[name].placeholder;
      }
    };
    prefill(function(){
      var f, c;
      f = state.form;
      f.email = "test@debug.com";
      f.name = "Test User";
      f.phone = "+380665243646";
      f.address = "664 Cypress Lane, Campbell, CA, United States";
      f.notes = "Some test notes";
      c = state.form.creditCard;
      c.card = "5105 1051 0510 5100";
      c.expDate = "05/17";
      c.cvv = "333";
      return state.form.agreed = true;
    });
    x$ = state;
    x$.investigateDate = investigateDate;
    x$.getEventInstanceId = getEventInstanceId;
    x$.placeholder = placeholder;
    x$.closeError = closeError;
    x$.checkout = checkout;
    x$.validate = validate;
    x$.agree = agree;
    x$.fields = fields;
    x$.few = few;
    x$.expDateChanged = expDateChanged;
    x$.cardChanged = cardChanged;
    x$.disabledOrder = disabledOrder;
    x$.typing = typing;
    x$.message = message;
    return state;
  };
});
// Generated by LiveScript 1.3.1
angular.module('ablsdk').service('ablcalc', function($xabl, $timeout, p, debug, test, typecheck){
  var sum;
  sum = function(arr){
    switch (false) {
    case typeof arr !== 'undefined':
      return 0;
    case typeof arr !== null:
      return 0;
    default:
      return p.sum(
      arr);
    }
  };
  return function(inputNewCharges, inputPrevousCharges, paid){
    var prevousCharges, newCharges, ref$, makeNewCharge, byPrice, makeOldCharge, oldAmounts, exclude, availableAmounts, getAmounts, state, totalAdjustment, calcSubtotal, calcTaxFee, calcTaxesFees, showPrice, calcPrice, showAddonPrice, calcAddonPrice, totalAddons, calcCoupon, warning, calcTotal, calcPreviousTotal, deposit, calcBalanceDue, adjustment, coupon;
    prevousCharges = inputPrevousCharges != null
      ? inputPrevousCharges
      : [];
    newCharges = (ref$ = inputNewCharges != null ? inputNewCharges.filter(function(it){
      return it.status === 'active';
    }) : void 8) != null
      ? ref$
      : [];
    debug({
      prevousCharges: prevousCharges,
      newCharges: newCharges,
      inputNewCharges: inputNewCharges,
      inputPrevousCharges: inputPrevousCharges
    });
    makeNewCharge = function(charge){
      return {
        name: charge.name,
        quantity: 0,
        amount: charge.amount,
        _id: charge._id
      };
    };
    byPrice = function(a, b){
      return b.amount - a.amount;
    };
    makeOldCharge = function(arr){
      return {
        name: arr[0].name,
        amount: arr[0].amount,
        quantity: arr.length,
        _ids: p.map(function(it){
          return it._id;
        })(
        arr)
      };
    };
    oldAmounts = function(type){
      return p.sortWith(byPrice)(
      p.map(makeOldCharge)(
      p.map(function(it){
        return it[1];
      })(
      p.objToPairs(
      p.groupBy(function(it){
        return it.name + it.amount;
      })(
      p.filter(function(it){
        return it.type === type;
      })(
      prevousCharges))))));
    };
    exclude = curry$(function(type, charge){
      var old;
      old = p.find(function(it){
        return charge.name === it.name && charge.amount === it.amount;
      })(
      oldAmounts(type));
      if (old != null) {
        old.old = true;
      }
      return old == null;
    });
    availableAmounts = function(type){
      return p.sortWith(byPrice)(
      p.filter(exclude(type))(
      p.map(makeNewCharge)(
      p.filter(function(it){
        return it.type === type;
      })(
      newCharges))));
    };
    getAmounts = function(type){
      return p.concat(
      p.map(function(it){
        return it(type);
      })(
      [oldAmounts, availableAmounts]));
    };
    test(function(){
      return getAmounts('aap').length > 0;
    });
    test(function(){
      var top;
      top = p.head(
      getAmounts('app'));
      if (!top) {
        return true;
      }
      if (top.amount == null || top.quantity == null || top.name == null) {
        return false;
      }
    });
    state = {
      attendees: getAmounts('aap'),
      addons: getAmounts('addon')
    };
    totalAdjustment = function(){
      return p.sum(
      p.map(function(it){
        return it.amount;
      })(
      adjustment.list));
    };
    calcSubtotal = function(){
      return sum(
      state.attendees.map(calcPrice)) + totalAdjustment() + totalAddons();
    };
    calcTaxFee = function(charge){
      switch (false) {
      case charge.type !== 'tax':
        return calcSubtotal() / 100 * charge.amount;
      case charge.type !== 'fee':
        return sum(
        state.attendees.map(function(it){
          return it.quantity;
        })) * charge.amount;
      default:
        return 0;
      }
    };
    calcTaxesFees = function(){
      return sum(
      newCharges.map(calcTaxFee));
    };
    showPrice = function(attendee){
      var ref$, ref1$, ref2$;
      return (ref$ = (ref1$ = newCharges.filter(function(it){
        return it.type === 'aap' && it.name === attendee.name;
      })) != null ? (ref2$ = ref1$[0]) != null ? ref2$.amount : void 8 : void 8) != null ? ref$ : 0;
    };
    calcPrice = function(attendee){
      return showPrice(attendee) * attendee.quantity;
    };
    showAddonPrice = function(addon){
      return sum(
      state.addons.filter(function(it){
        return it.name === addon.name;
      }).map(function(it){
        return it.amount;
      }));
    };
    calcAddonPrice = function(addon){
      return showAddonPrice(addon) * addon.quantity;
    };
    totalAddons = function(){
      return sum(
      state.addons.map(calcAddonPrice));
    };
    calcCoupon = function(){
      var subtotal, amountOff, _;
      subtotal = calcSubtotal();
      amountOff = function(){
        switch (false) {
        case !(coupon.codes[0].amountOff < subtotal):
          return coupon.codes[0].amountOff;
        default:
          return subtotal;
        }
      };
      _ = (function(){
        switch (false) {
        case coupon.codes.length !== 0:
          return 0;
        case coupon.codes[0].amountOff == null:
          return amountOff();
        case coupon.codes[0].percentOff == null:
          return subtotal / 100 * coupon.codes[0].percentOff;
        default:
          return 0;
        }
      }());
      return _;
    };
    warning = function(charge, name){
      var removed, type, changed, res;
      removed = charge.status === 'inactive';
      type = charge.type;
      changed = charge.old;
      name = (function(){
        switch (false) {
        case type !== 'aap':
          return "pricing level";
        case type !== 'addon':
          return "add-on";
        }
      }());
      res = (function(){
        switch (false) {
        case !(removed && name === 'removed'):
          return "Warning: This " + name + " no longer exists. You can only reduce the quantity at this " + name + ". If you wish to offer another " + name + " at this price, please create on Adjustment to currect the price.";
        case !(changed && name === 'changed'):
          return "Warning: This " + name + " has changed since the booking was created. You can only reduce the quantity at this " + name + ". If you wish to offer the old " + name + ", please create an Adjustment.";
        case !((removed || changed) && name === 'mutated'):
          return true;
        default:
          return "";
        }
      }());
      return res;
    };
    calcTotal = function(){
      return calcSubtotal() + calcTaxesFees() - calcCoupon();
    };
    calcPreviousTotal = function(){
      return p.sum(
      p.map(function(it){
        return it.amount;
      })(
      prevousCharges));
    };
    deposit = p.sum(
    p.map(function(it){
      return it.amount;
    })(
    paid != null
      ? paid
      : []));
    calcBalanceDue = function(){
      return -(calcTotal() - deposit);
    };
    adjustment = {
      list: p.filter(function(it){
        return it.type === 'adjustment';
      })(
      prevousCharges),
      description: "",
      amount: "",
      isEdit: false,
      show: false,
      add: function(){
        var newItem;
        newItem = {
          description: adjustment.description,
          amount: adjustment.amount
        };
        newItem.amount *= 100;
        adjustment.list.push(newItem);
        adjustment.description = "";
        adjustment.amount = "";
        adjustment.show = false;
        return adjustment.isEdit = false;
      },
      removable: function(item){
        return item._id == null;
      },
      remove: function(item){
        var index;
        index = adjustment.list.indexOf(item);
        return adjustment.list.splice(index, 1);
      },
      edit: function(c){
        if (adjustment.isEdit) {
          adjustment.add();
        }
        adjustment.description = c.description;
        adjustment.amount = c.amount / 100;
        adjustment.show = true;
        adjustment.isEdit = true;
        return adjustment.remove(c);
      }
    };
    coupon = {
      codes: [],
      calc: calcCoupon,
      show: false,
      edit: function(c){
        coupon.code = c.code;
        coupon.remove(c);
        return coupon.show = true;
      },
      remove: function(c){
        var index;
        index = coupon.codes.indexOf(c);
        if (index > -1) {
          return coupon.codes.splice(index, 1);
        }
      },
      add: function(activity){
        var ref$, apply;
        if (((ref$ = coupon.code) != null ? ref$ : "").length === 0) {
          return;
        }
        coupon.code = coupon.code.toUpperCase();
        coupon.error = (function(){
          switch (false) {
          case coupon.code.length !== 0:
            return "Code is required";
          case !(coupon.code.length < 6):
            return "6 chars are required";
          default:
            return "";
          }
        }());
        if (coupon.error.length > 0) {
          return;
        }
        apply = function(data){
          var success;
          success = function(){
            coupon.codes.push(data);
            coupon.code = "";
            coupon.success = "Coupon " + data.couponId + " added successfully";
            coupon.show = false;
            $timeout(function(){
              var ref$;
              return ref$ = coupon.success, delete coupon.success, ref$;
            }, 3000);
            return "";
          };
          return coupon.error = (function(){
            switch (false) {
            case !(data.maxRedemptions !== 0 && data.maxRedemptions <= data.redemptions):
              return "This coupon has been fully redeemed.";
            case !(moment().diff(moment(data.redeemBy), 'minutes') > 0):
              return "This coupon is expired";
            case !(data.activities.length > 0 && data.activities[0] !== activity):
              return "This coupon is not valid for this activity.";
            default:
              return success();
            }
          }());
        };
        return $xabl.get("coupon/" + coupon.code).success(function(data){
          return apply(data);
        }).error(function(data){
          var ref$, ref1$;
          return coupon.error = (ref$ = data != null ? (ref1$ = data.errors) != null ? ref1$[0] : void 8 : void 8) != null ? ref$ : "Coupon not found";
        });
      },
      code: ""
    };
    return {
      warning: warning,
      coupon: coupon,
      adjustment: adjustment,
      addons: state.addons,
      attendees: state.attendees,
      showAttendees: function(){
        return p.join(", ")(
        p.map(function(o){
          return o.quantity + " " + o.name;
        })(
        state.attendees));
      },
      showAddons: function(){
        return p.join(", ")(
        p.map(function(o){
          return o.quantity + " " + o.name;
        })(
        state.addons));
      },
      totalWithoutTaxesfees: calcSubtotal,
      calcCoupon: calcCoupon,
      calcTaxFee: calcTaxFee,
      calcTaxesFees: calcTaxesFees,
      showPrice: showPrice,
      calcPrice: calcPrice,
      showAddonPrice: showAddonPrice,
      calcAddonPrice: calcAddonPrice,
      totalAddons: totalAddons,
      calcSubtotal: calcSubtotal,
      calcTotal: calcTotal,
      calcPreviousTotal: calcPreviousTotal,
      calcBalanceDue: calcBalanceDue
    };
  };
});
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
// Generated by LiveScript 1.3.1
angular.module('ablsdk').service('browser', function($window){
  var name;
  name = function(){
    var userAgent, browsers, key;
    userAgent = $window.navigator.userAgent;
    browsers = {
      chrome: /chrome/i,
      safari: /safari/i,
      firefox: /firefox/i,
      ie: /msie/i
    };
    for (key in browsers) {
      if (browsers[key].test($window.navigator.userAgent)) {
        return key;
      }
    }
    return 'unknown';
  };
  return {
    name: name()
  };
});
// Generated by LiveScript 1.3.1
angular.module('ablsdk').filter('capitalize', function(){
  return function(input){
    if (angular.isString(input) && input.length > 0) {
      return input.charAt(0).toUpperCase() + input.substr(1).toLowerCase();
    } else {
      return input;
    }
  };
}).filter('capitalizeAll', function(){
  return function(input){
    if (angular.isString(input) && input.length > 0) {
      return input.split(' ').map(function(it){
        return it.charAt(0).toUpperCase() + it.substr(1).toLowerCase();
      }).join(' ');
    } else {
      return input;
    }
  };
});
// Generated by LiveScript 1.3.1
var toString$ = {}.toString;
angular.module('ablsdk').service('crud', function($xabl, $rootScope, debug, $mdDialog, safeApply, watcher, p){
  return function(url, initOptions){
    var parsedUrl, state, factory, provider, ref$, configureUrl, $scope, i, removeFromMemory, save, update, add, success, fetch, splice, remove, watchers, improve;
    parsedUrl = url.split('@');
    url = parsedUrl[0];
    state = {
      loading: false,
      frontendify: function(data, url){
        var parts, part, array;
        parts = url.split('/');
        part = parts[parts.length - 1];
        return array = (function(){
          switch (false) {
          case toString$.call(data).slice(8, -1) !== 'Array':
            return data;
          case toString$.call(data.list).slice(8, -1) !== 'Array':
            return data.list;
          case toString$.call(data[part]).slice(8, -1) !== 'Array':
            return data[part];
          case toString$.call(data).slice(8, -1) !== 'Object':
            return [data];
          default:
            return [];
          }
        }());
      }
    };
    factory = {
      localStorage: {
        remove: function(item){},
        add: function(item){},
        update: function(item){},
        fetch: function(item){}
      },
      memory: {
        remove: function(item){
          return removeFromMemory(item);
        },
        add: function(item, callback){
          Array.prototype.push.call(i, item);
          return typeof callback == 'function' ? callback(item) : void 8;
        },
        update: function(item, callback){
          return typeof callback == 'function' ? callback(item) : void 8;
        },
        fetch: function(){
          return state.loading = false;
        }
      },
      backend: {
        remove: function(item){
          return $xabl['delete'](url + "/" + item._id).success(function(){
            return removeFromMemory(item);
          });
        },
        update: function(item, callback){
          return $xabl.update(url + "/" + item._id, item).success(function(data){
            state.loading = false;
            return typeof callback == 'function' ? callback(data) : void 8;
          });
        },
        add: function(item, callback){
          return $xabl.create(url, item).success(function(data){
            debug('backend-success', data);
            success(data);
            return typeof callback == 'function' ? callback(data) : void 8;
          });
        },
        fetch: function(){
          var options;
          options = angular.copy(i.options);
          delete options.$url;
          return $xabl.get(configureUrl(url), {
            params: options
          }).success(function(data, status, headers){
            var params, r;
            i.length = 0;
            params = function(name){
              var header, parser, err;
              header = headers()[name];
              if (header != null) {
                parser = document.createElement('a');
                parser.href = headers()[name];
                try {
                  return JSON.parse('{"' + decodeURI(parser.search.substr(1, 2000)).replace(/"/g, '\\"').replace(/&/g, '","').replace(/=/g, '":"') + '"}');
                } catch (e$) {
                  err = e$;
                  console.error(err, parser.search);
                  return undefined;
                }
              } else {
                return undefined;
              }
            };
            i.options.total = (r = params('x-last-page-url'), r != null
              ? parseInt(r.page) * parseInt(r.pageSize)
              : data.length);
            i.options.pageSize = (r = params('x-first-page-url'), r != null
              ? parseInt(r.pageSize)
              : data.length);
            state.loading = false;
            return success(data);
          });
        }
      }
    };
    provider = factory[(ref$ = parsedUrl[1]) != null ? ref$ : 'backend'];
    configureUrl = function(url){
      var state, replace, u;
      state = {
        url: url
      };
      replace = function(pair){
        return state.url = state.url.replace(':' + pair[0], pair[1]);
      };
      u = i.getOptions().$url;
      if (u != null) {
        p.each(replace)(
        p.objToPairs(
        u));
      }
      return state.url;
    };
    $scope = $rootScope.$new();
    $scope.items = [];
    i = $scope.items;
    state.loading = false;
    removeFromMemory = function(item){
      var index;
      index = i.indexOf(item);
      if (index > -1) {
        return Array.prototype.splice.call(i, index, 1);
      }
    };
    save = function(item, callback){
      if (item._id != null) {
        return update(item, callback);
      } else {
        return add(item, callback);
      }
    };
    update = function(item, callback){
      if (state.loading) {
        return;
      }
      return provider.update(item, callback);
    };
    add = function(item, callback){
      if (state.loading) {
        return;
      }
      return provider.add(item, callback);
    };
    success = function(data){
      var result, type, extendObject;
      result = state.frontendify(data, url);
      type = toString$.call(result).slice(8, -1);
      switch (type) {
      case 'Array':
        Array.prototype.push.apply(i, result);
        break;
      case 'Object':
        extendObject = function(pair){
          return i[pair[0]] = pair[1];
        };
        p.each(extendObject)(
        p.objToPairs(
        result));
      }
      return state.loading = false;
    };
    i.options = {};
    i.converter = function(converter){
      state.frontendify = converter.frontendify;
      state.backendify = converter.backendify;
      return i;
    };
    i.getOptions = function(){
      return i.options;
    };
    fetch = function(options){
      if (state.loading) {
        return;
      }
      switch (toString$.call(options).slice(8, -1)) {
      case 'Function':
        i.getOptions = options;
        return fetch({});
      case 'Number':
        i.options.page = options;
        break;
      case 'Object':
        i.options = angular.extend({}, i.getOptions(), options);
      }
      state.loading = true;
      if (i.options.page != null) {
        if (i.options.page === 1) {
          delete i.options.page;
        } else {
          i.options.page -= 1;
        }
      }
      return provider.fetch();
    };
    fetch(initOptions);
    splice = function(){
      var removed;
      if (state.loading) {
        return;
      }
      removed = Array.prototype.splice.apply(i, arguments);
      return removed.forEach(provider.remove);
    };
    remove = function(item, $event, options){
      var defaultOptions, confirm;
      if (state.loading) {
        return;
      }
      defaultOptions = {
        title: "Confirm Delete",
        content: "Are you sure you want to delete this item?",
        ok: 'Confirm',
        cancel: 'Cancel'
      };
      confirm = $mdDialog.confirm({
        controller: 'confirm2',
        templateUrl: 'confirm',
        locals: {
          options: angular.extend({}, defaultOptions, options)
        },
        targetEvent: $event
      });
      return $mdDialog.show(confirm).then(function(result){
        if (result === true) {
          return provider.remove(item);
        }
      });
    };
    watchers = [];
    improve = function(source){
      var observers, bind;
      observers = [];
      bind = curry$(function(name, func){
        var bound, mutate;
        bound = [];
        improve(bound);
        mutate = function(){
          var mutated;
          mutated = Array.prototype[name].call(source, func);
          bound.length = 0;
          return Array.prototype.push.apply(bound, mutated);
        };
        observers.push(mutate);
        mutate();
        return bound;
      });
      source.loading = function(){
        return state.loading;
      };
      source.toArray = function(){
        var a;
        a = [];
        Array.prototype.push.apply(a, source);
        return a;
      };
      source.fetchOn = function(array, $scope){
        $scope.$watch(array, bind$(i, 'fetch'), true);
        return source;
      };
      source.watch = function(array, $scope){
        var func;
        func = function(){
          return safeApply(function(){
            return observers.forEach(function(it){
              return it();
            });
          });
        };
        if ($scope != null) {
          watchers.push({
            array: $scope[array],
            func: func
          });
          $scope.$watch(array, func, true);
        } else {
          watchers.push({
            array: array,
            func: func
          });
          watcher.watch(array, func);
        }
        return source;
      };
      source.watch(source);
      ['map', 'filter'].forEach(function(item){
        return source[item] = bind(item);
      });
      source.push = add;
      source.save = save;
      source.fetch = fetch;
      source.remove = remove;
      source.splice = splice;
      return source.toArray = function(){
        return angular.copy(source);
      };
    };
    i.listen = function($scope){
      $scope.$on('$destroy', function(){
        var i$, ref$, len$, item, results$ = [];
        for (i$ = 0, len$ = (ref$ = watchers).length; i$ < len$; ++i$) {
          item = ref$[i$];
          results$.push(watcher.unwatch(item.array, item.func));
        }
        return results$;
      });
      return i;
    };
    improve(i);
    return i;
  };
});
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
function bind$(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}
// Generated by LiveScript 1.3.1
angular.module('ablsdk').service('abldate', function(debug){
  return function(timeZone){
    var hack, dst;
    hack = function(input, tz){
      var d, z;
      d = bind$(moment(input), 'format');
      z = bind$(tz, 'format');
      return moment(d('YYYY-MM-DD HH:mm ') + z('Z'), "YYYY-MM-DD HH:mm Z");
    };
    dst = function(d, date){
      return d.add(moment(date).tz(timeZone).utcOffset() - d.utcOffset(), 'minute');
    };
    return {
      backendify: function(date){
        var d;
        d = hack(date, moment().tz(timeZone)).tz(timeZone);
        dst(d);
        return d.tz("UTC").format("YYYY-MM-DD\\THH:mm:ss\\Z");
      },
      frontendify: function(date){
        var d;
        d = moment(date).tz(timeZone);
        dst(d, d);
        return hack(d, moment(date)).toDate();
      }
    };
  };
});
function bind$(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}
// Generated by LiveScript 1.3.1
var toString$ = {}.toString;
angular.module('ablsdk').factory('debug', function(enabledDebug){
  return function(input){
    var ref$;
    if (enabledDebug) {
      switch (toString$.call(input).slice(8, -1)) {
      case 'Function':
        return input();
      default:
        return typeof console != 'undefined' && console !== null ? (ref$ = console.log) != null ? ref$.apply(console, arguments) : void 8 : void 8;
      }
    }
  };
});
// Generated by LiveScript 1.3.1
angular.module('ablsdk').service('ablfacade', function(ablbook, ablslot){
  return function(activity, callback){
    var book, slot;
    book = ablbook(activity, callback);
    slot = ablslot(activity, book.calendar);
    return {
      book: book,
      slot: slot
    };
  };
});
// Generated by LiveScript 1.3.1
angular.module('ablsdk').service('formula', function(p, debug){
  var getSlotPrice, getVisualPrice;
  getSlotPrice = function(type, slot){
    var arr, ref$;
    arr = (ref$ = slot != null ? slot.charges : void 8) != null
      ? ref$
      : [];
    return function(it){
      var ref$;
      return (ref$ = it != null ? it.amount : void 8) != null ? ref$ : 0;
    }(
    p.find(function(it){
      return it.type === type || it.subtype === type || it.description === type;
    })(
    arr));
  };
  getVisualPrice = function(ac){
    var ref$, merge, onlyAdult, all, mergedAdults, mergedAll, max, final;
    if ((ac != null ? (ref$ = ac.timeslots) != null ? ref$.length : void 8 : void 8) > 0) {
      merge = function(arrays){
        return [].concat.apply([], arrays);
      };
      onlyAdult = function(slot){
        var type, ref$;
        type = 'Adult';
        return p.map(function(it){
          return it.amount;
        })(
        p.filter(function(it){
          return it.status === 'active';
        })(
        p.filter(function(it){
          return it.type === type || it.subtype === type || it.description === type;
        })(
        (ref$ = slot != null ? slot.charges : void 8) != null
          ? ref$
          : [])));
      };
      all = function(slot){
        var ref$;
        return p.map(function(it){
          return it.amount;
        })(
        p.filter(function(it){
          return it.status === 'active';
        })(
        (ref$ = slot != null ? slot.charges : void 8) != null
          ? ref$
          : []));
      };
      mergedAdults = merge(ac.timeslots.map(onlyAdult));
      mergedAll = merge(ac.timeslots.map(all));
      max = function(array){
        return Math.max.apply(Math, array);
      };
      final = (function(){
        switch (false) {
        case !(mergedAdults.length > 0):
          return max(mergedAdults);
        case !(mergedAll.length > 0):
          return max(mergedAll);
        default:
          return 0;
        }
      }());
      return final;
    } else {
      return 'Non';
    }
  };
  return {
    getSlotPrice: function(slot){
      return getSlotPrice('Adult', slot);
    },
    getVisualPrice: getVisualPrice,
    getAdultPrice: function(ac){
      var ref$;
      return getSlotPrice('Adult', ac != null ? (ref$ = ac.timeslots) != null ? ref$[0] : void 8 : void 8);
    },
    getYouthPrice: function(ac){
      var ref$;
      return getSlotPrice('Youth', ac != null ? (ref$ = ac.timeslots) != null ? ref$[0] : void 8 : void 8);
    }
  };
});
// Generated by LiveScript 1.3.1
angular.module('ablsdk').filter('mdate', function(debug){
  return function(obj, mask){
    if (obj != null) {
      return obj.format(mask);
    } else {
      return null;
    }
  };
});
// Generated by LiveScript 1.3.1
var toString$ = {}.toString;
angular.module('ablsdk').service('p', function(){
  var flatten, first;
  flatten = function(xs){
    var x;
    return [].concat.apply([], (function(){
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
        x = ref$[i$];
        if (toString$.call(x).slice(8, -1) === 'Array') {
          results$.push(flatten(x));
        } else {
          results$.push(x);
        }
      }
      return results$;
    }()));
  };
  return {
    head: first = function(xs){
      return xs[0];
    },
    each: curry$(function(f, xs){
      var i$, len$, x;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        f(x);
      }
      return xs;
    }),
    isItNaN: function(x){
      return x !== x;
    },
    all: curry$(function(f, xs){
      var i$, len$, x;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        if (!f(x)) {
          return false;
        }
      }
      return true;
    }),
    map: curry$(function(f, xs){
      return xs.map(f);
    }),
    fold: curry$(function(f, memo, xs){
      var i$, len$, x;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        memo = f(memo, x);
      }
      return memo;
    }),
    filter: curry$(function(f, xs){
      var i$, len$, x, results$ = [];
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        if (f(x)) {
          results$.push(x);
        }
      }
      return results$;
    }),
    find: curry$(function(f, xs){
      var i$, len$, x;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        if (f(x)) {
          return x;
        }
      }
    }),
    pairsToObj: function(object){
      var i$, len$, x, resultObj$ = {};
      for (i$ = 0, len$ = object.length; i$ < len$; ++i$) {
        x = object[i$];
        resultObj$[x[0]] = x[1];
      }
      return resultObj$;
    },
    objToPairs: function(object){
      var key, value, results$ = [];
      for (key in object) {
        value = object[key];
        results$.push([key, value]);
      }
      return results$;
    },
    values: function(object){
      var key, value, results$ = [];
      for (key in object) {
        value = object[key];
        results$.push(value);
      }
      return results$;
    },
    any: curry$(function(f, xs){
      var i$, len$, x;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        if (f(x)) {
          return true;
        }
      }
      return false;
    }),
    notAny: curry$(function(f, xs){
      var i$, len$, x;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        if (f(x)) {
          return false;
        }
      }
      return true;
    }),
    sum: function(xs){
      var result, i$, len$, x;
      result = 0;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        result += x;
      }
      return result;
    },
    sort: function(xs){
      return xs.concat().sort(function(x, y){
        if (x > y) {
          return 1;
        } else if (x < y) {
          return -1;
        } else {
          return 0;
        }
      });
    },
    concat: function(xss){
      return [].concat.apply([], xss);
    },
    concatMap: curry$(function(f, xs){
      var x;
      return [].concat.apply([], (function(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
          x = ref$[i$];
          results$.push(f(x));
        }
        return results$;
      }()));
    }),
    flatten: flatten,
    groupBy: curry$(function(f, xs){
      var results, i$, len$, x, key;
      results = {};
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        key = f(x);
        if (key in results) {
          results[key].push(x);
        } else {
          results[key] = [x];
        }
      }
      return results;
    }),
    sortWith: curry$(function(f, xs){
      return xs.concat().sort(f);
    }),
    sortBy: curry$(function(f, xs){
      return xs.concat().sort(function(x, y){
        if (f(x) > f(y)) {
          return 1;
        } else if (f(x) < f(y)) {
          return -1;
        } else {
          return 0;
        }
      });
    }),
    reverse: function(xs){
      return xs.concat().reverse();
    },
    split: curry$(function(sep, str){
      return str.split(sep);
    }),
    join: curry$(function(sep, xs){
      return xs.join(sep);
    }),
    lines: function(str){
      if (!str.length) {
        return [];
      }
      return str.split('\n');
    },
    unlines: function(it){
      return it.join('\n');
    },
    words: function(str){
      if (!str.length) {
        return [];
      }
      return str.split(/[ ]+/);
    },
    unwords: function(it){
      return it.join(' ');
    },
    chars: function(it){
      return it.split('');
    },
    unchars: function(it){
      return it.join('');
    },
    repeat: curry$(function(n, str){
      var result, i$;
      result = '';
      for (i$ = 0; i$ < n; ++i$) {
        result += str;
      }
      return result;
    }),
    capitalize: function(str){
      return str.charAt(0).toUpperCase() + str.slice(1);
    },
    camelize: function(it){
      return it.replace(/[-_]+(.)?/g, function(arg$, c){
        return (c != null ? c : '').toUpperCase();
      });
    },
    dasherize: function(str){
      return str.replace(/([^-A-Z])([A-Z]+)/g, function(arg$, lower, upper){
        return lower + "-" + (upper.length > 1
          ? upper
          : upper.toLowerCase());
      }).replace(/^([A-Z]+)/, function(arg$, upper){
        if (upper.length > 1) {
          return upper + "-";
        } else {
          return upper.toLowerCase();
        }
      });
    }
  };
});
function curry$(f, bound){
  var context,
  _curry = function(args) {
    return f.length > 1 ? function(){
      var params = args ? args.concat() : [];
      context = bound ? context || this : this;
      return params.push.apply(params, arguments) <
          f.length && arguments.length ?
        _curry.call(context, params) : f.apply(context, params);
    } : f;
  };
  return _curry();
}
// Generated by LiveScript 1.3.1
angular.module('ablsdk').factory('prefill', function(debug, safeApply, $window){
  return function(func){
    return debug(function(){
      $window.prefill = function(){
        var params;
        params = arguments;
        return safeApply(function(){
          return func.apply(null, params);
        });
      };
      if ($window.parent != null) {
        return $window.parent.prefill = $window.prefill;
      }
    });
  };
});
// Generated by LiveScript 1.3.1
angular.module('ablsdk').filter('price', function($filter){
  return function(amount){
    return $filter('currency')(amount / 100);
  };
});
// Generated by LiveScript 1.3.1
angular.module('ablsdk').service('safeApply', function($rootScope){
  return function(fn){
    var phase;
    phase = $rootScope.$$phase;
    if (phase === '$apply' || phase === '$digest') {
      return fn();
    } else {
      return $rootScope.$apply(fn);
    }
  };
});
